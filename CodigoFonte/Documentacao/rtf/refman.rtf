{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment VC_TP_Doc  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1.0 \par
}}VC_TP_Doc}
{\comment Generated by doxygen1.9.3.}
{\creatim \yr2024\mo6\dy10\hr21\min47\sec31}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt VC_TP_Doc}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 1.0\par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt Mon Jun 10 2024 }}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b IVC} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b OVC} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b C:/Program Files (x86)/VisaoComputador_TP/CodigoFonte/{\b main.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Program Files (x86)/VisaoComputador_TP/CodigoFonte/{\b vc.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Program Files (x86)/VisaoComputador_TP/CodigoFonte/{\b vc.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IVC Struct Reference\par \pard\plain 
{\tc\tcl2 \v IVC}
{\xe \v IVC}
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
\par
{
{\f2 #include <vc.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char * {\b data}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b width}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b height}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b channels}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b levels}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b bytesperline}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v bytesperline\:IVC}
{\xe \v IVC\:bytesperline}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int IVC::bytesperline}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v channels\:IVC}
{\xe \v IVC\:channels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int IVC::channels}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v data\:IVC}
{\xe \v IVC\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char* IVC::data}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v height\:IVC}
{\xe \v IVC\:height}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int IVC::height}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v levels\:IVC}
{\xe \v IVC\:levels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int IVC::levels}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v width\:IVC}
{\xe \v IVC\:width}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int IVC::width}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Program Files (x86)/VisaoComputador_TP/CodigoFonte/{\b vc.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
OVC Struct Reference\par \pard\plain 
{\tc\tcl2 \v OVC}
{\xe \v OVC}
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
\par
{
{\f2 #include <vc.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b x}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b y}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b width}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b height}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b area}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b xc}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b yc}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b perimeter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b label}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v area\:OVC}
{\xe \v OVC\:area}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int OVC::area}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v height\:OVC}
{\xe \v OVC\:height}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int OVC::height}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v label\:OVC}
{\xe \v OVC\:label}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int OVC::label}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v perimeter\:OVC}
{\xe \v OVC\:perimeter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int OVC::perimeter}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v width\:OVC}
{\xe \v OVC\:width}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int OVC::width}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v x\:OVC}
{\xe \v OVC\:x}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int OVC::x}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v xc\:OVC}
{\xe \v OVC\:xc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int OVC::xc}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v y\:OVC}
{\xe \v OVC\:y}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int OVC::y}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v yc\:OVC}
{\xe \v OVC\:yc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int OVC::yc}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Program Files (x86)/VisaoComputador_TP/CodigoFonte/{\b vc.h}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Program Files (x86)/VisaoComputador_TP/CodigoFonte/main.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Program Files (x86)/VisaoComputador_TP/CodigoFonte/main.cpp}
{\xe \v C:/Program Files (x86)/VisaoComputador_TP/CodigoFonte/main.cpp}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include <string>}\par
{\f2 #include <chrono>}\par
{\f2 #include <opencv2\\opencv.hpp>}\par
{\f2 #include <opencv2\\core.hpp>}\par
{\f2 #include <opencv2\\highgui.hpp>}\par
{\f2 #include <opencv2\\videoio.hpp>}\par
{\f2 #include "vc.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vc_timer} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
cv::Mat {\b IVC_to_Mat1Channel} ({\b IVC} *src)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v IVC_to_Mat1Channel\:main.cpp}
{\xe \v main.cpp\:IVC_to_Mat1Channel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
cv::Mat IVC_to_Mat1Channel ({\b IVC} *  {\i src})}}
\par
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 39 \{\par
40     {\cf19 return} cv::Mat(src->height, src->width, CV_8UC1, src->data);\par
41 \}\par
}
}
{\xe \v main\:main.cpp}
{\xe \v main.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (void )}}
\par
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 44 \{\par
45     {\cf20 // V\'EF\'BF\'BDdeo}\par
46     {\cf18 char} videofile[20] = {\cf22 "video_resistors.mp4"};\par
47     cv::VideoCapture capture;\par
48     {\cf17 struct}\par
49     \{\par
50         {\cf18 int} width, height;\par
51         {\cf18 int} ntotalframes;\par
52         {\cf18 int} fps;\par
53         {\cf18 int} nframe;\par
54     \} video;\par
55     {\cf20 // Outros}\par
56     std::string str;\par
57     {\cf18 int} key = 0;\par
58 \par
59     {\cf20 /* Leitura de v\'EF\'BF\'BDdeo de um ficheiro */}\par
60     {\cf20 /* NOTA IMPORTANTE:}\par
61 {\cf20     O ficheiro video.avi dever\'EF\'BF\'BD estar localizado no mesmo direct\'EF\'BF\'BDrio que o ficheiro de c\'EF\'BF\'BDdigo fonte.}\par
62 {\cf20     */}\par
63     capture.open(videofile);\par
64 \par
65     {\cf20 /* Em alternativa, abrir captura de v\'EF\'BF\'BDdeo pela Webcam #0 */}\par
66     {\cf20 // capture.open(0, cv::CAP_DSHOW); // Pode-se utilizar apenas capture.open(0);}\par
67 \par
68     {\cf20 /* Verifica se foi poss\'EF\'BF\'BDvel abrir o ficheiro de v\'EF\'BF\'BDdeo */}\par
69     {\cf19 if} (!capture.isOpened())\par
70     \{\par
71         std::cerr << {\cf22 "Erro ao abrir o ficheiro de v\'EF\'BF\'BDdeo!\\n"};\par
72         {\cf19 return} 1;\par
73     \}\par
74 \par
75     {\cf20 /* N\'EF\'BF\'BDmero total de frames no v\'EF\'BF\'BDdeo */}\par
76     video.ntotalframes = (int)capture.get(cv::CAP_PROP_FRAME_COUNT);\par
77     {\cf20 /* Frame rate do v\'EF\'BF\'BDdeo */}\par
78     video.fps = (int)capture.get(cv::CAP_PROP_FPS);\par
79     {\cf20 /* Resolu\'EF\'BF\'BD\'EF\'BF\'BDo do v\'EF\'BF\'BDdeo */}\par
80     video.width = (int)capture.get(cv::CAP_PROP_FRAME_WIDTH);\par
81     video.height = (int)capture.get(cv::CAP_PROP_FRAME_HEIGHT);\par
82 \par
83     {\cf20 /* Cria uma janela para exibir o v\'EF\'BF\'BDdeo */}\par
84     cv::namedWindow({\cf22 "VC - VIDEO"}, cv::WINDOW_AUTOSIZE);\par
85 \par
86     {\cf20 /* Inicia o timer */}\par
87     vc_timer();\par
88 \par
89     cv::Mat frame;\par
90 \par
91     IVC *imagesrc = vc_image_new(video.width, video.height, 3, 255);\par
92     IVC *image_resistances_segmentation = vc_image_new(video.width, video.height, 1, 255);\par
93     IVC *resistances_segmentation_dilate = vc_image_new(video.width, video.height, 1, 255);\par
94     IVC *resistances_labelled = vc_image_new(video.width, video.height, 1, 255);\par
95     IVC *imagesrc2 = vc_image_new(video.width, video.height, 3, 255);\par
96     IVC *final_image = vc_image_new(video.width, video.height, 3, 255);\par
97     IVC *green_segmentation = vc_image_new(video.width, video.height, 1, 255);\par
98     IVC *resistance_bands_dilate = vc_image_new(video.width, video.height, 1, 255);\par
99     IVC *blue_segmentation = vc_image_new(video.width, video.height, 1, 255);\par
100     IVC *red_segmentation = vc_image_new(video.width, video.height, 1, 255);\par
101     IVC *brown_segmentation = vc_image_new(video.width, video.height, 1, 255);\par
102     IVC *black_segmentation = vc_image_new(video.width, video.height, 1, 255);\par
103     IVC *orange_segmentation = vc_image_new(video.width, video.height, 1, 255);\par
104     IVC *red_segmentation_dilate = vc_image_new(video.width, video.height, 1, 255);\par
105     IVC *resistance_bands = vc_image_new(video.width, video.height, 1, 255);\par
106 \par
107     {\cf18 int} nblobs, i;\par
108     OVC *blobs;\par
109 \par
110     {\cf18 long} resistencias[6] = \{0, 0, 0, 0, 0, 0\};\par
111     {\cf18 int} resistorIndex = 0;\par
112 \par
113     {\cf18 int} totalResistorCount = 0;\par
114 \par
115     cv::Mat Mat_resistances_segmentation_dilate;\par
116     cv::Mat Mat2;\par
117     cv::Mat mat_red_segmentation_dilate;\par
118 \par
119     {\cf19 while} (key != {\cf23 'q'})\par
120     \{\par
121         {\cf18 int} currentResistorCount = 0;\par
122         {\cf20 /* Leitura de uma frame do v\'EF\'BF\'BDdeo */}\par
123         capture.read(frame);\par
124 \par
125         {\cf20 /* Verifica se conseguiu ler a frame */}\par
126         {\cf19 if} (frame.empty())\par
127             {\cf19 break};\par
128 \par
129         {\cf20 /* N\'EF\'BF\'BDmero da frame a processar */}\par
130         video.nframe = (int)capture.get(cv::CAP_PROP_POS_FRAMES);\par
131 \par
132         memcpy(imagesrc2->data, frame.data, video.width * video.height * 3);\par
133 \par
134         vc_bgr_to_hsv2(imagesrc2, imagesrc);\par
135 \par
136         vc_hsv_segmentation_final(imagesrc, image_resistances_segmentation);\par
137 \par
138         cv::Mat Mat_resistances_segmentation = IVC_to_Mat1Channel(image_resistances_segmentation);\par
139 \par
140         {\cf18 int} kernelSize = 7;\par
141         cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(kernelSize, kernelSize));\par
142         cv::dilate(Mat_resistances_segmentation, Mat_resistances_segmentation_dilate, kernel);\par
143 \par
144         memcpy(resistances_segmentation_dilate->data, Mat_resistances_segmentation_dilate.data, video.width * video.height);\par
145 \par
146         blobs = vc_binary_blob_labelling(resistances_segmentation_dilate, resistances_labelled, &nblobs);\par
147         {\cf19 if} (blobs != NULL)\par
148         \{\par
149             vc_binary_blob_info(resistances_labelled, blobs, nblobs);\par
150             {\cf19 for} (i = 0; i < nblobs; i++)\par
151             \{\par
152                 {\cf19 if} (blobs[i].area >= 6900)\par
153                 \{\par
154                     vc_draw_centerofgravity(resistances_labelled, &blobs[i], 1, 3);\par
155                     vc_draw_boundingbox(resistances_labelled, &blobs[i], 1);\par
156                     currentResistorCount++;\par
157 \par
158                     {\cf19 if} (blobs[i].yc >= 100 && blobs[i].yc < 108)\par
159                     \{\par
160                         totalResistorCount++;\par
161 \par
162                         vc_hsv_segmentation_resistencias(imagesrc, resistance_bands);\par
163 \par
164                         cv::Mat mat_resistance_bands = IVC_to_Mat1Channel(resistance_bands);\par
165 \par
166                         {\cf18 int} kernelSize2 = 8;\par
167                         cv::Mat kernel2 = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(kernelSize2, kernelSize2));\par
168                         cv::dilate(mat_resistance_bands, Mat2, kernel2);\par
169 \par
170                         memcpy(resistance_bands_dilate->data, Mat2.data, video.width * video.height);\par
171 \par
172                         {\cf18 int} widths[3] = \{0, 0, 0\};\par
173                         {\cf18 int} cores[3] = \{0, 0, 0\};\par
174 \par
175                         lookForWhite(resistance_bands_dilate, blobs[i].yc, widths);\par
176 \par
177                         {\cf20 // verde}\par
178                         vc_hsv_segmentation(imagesrc, green_segmentation, 79, 105, 28, 45, 35, 50);\par
179 \par
180                         {\cf20 // azul}\par
181                         vc_hsv_segmentation(imagesrc, blue_segmentation, 155, 200, 16, 40, 36, 52);\par
182 \par
183                         vc_hsv_segmentation_vermelho(imagesrc, red_segmentation);\par
184 \par
185                         cv::Mat mat_red_segmentation = IVC_to_Mat1Channel(red_segmentation);\par
186 \par
187                         {\cf18 int} kernelSize3 = 4;\par
188                         cv::Mat kernel3 = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(kernelSize3, kernelSize3));\par
189                         cv::dilate(mat_red_segmentation, mat_red_segmentation_dilate, kernel3);\par
190 \par
191                         memcpy(red_segmentation_dilate->data, mat_red_segmentation_dilate.data, video.width * video.height);\par
192 \par
193                         vc_hsv_segmentation_castanho(imagesrc, brown_segmentation);\par
194 \par
195                         {\cf20 // preto}\par
196                         vc_hsv_segmentation(imagesrc, black_segmentation, 35, 200, 3, 19, 15, 37);\par
197 \par
198                         {\cf20 // laranja}\par
199                         vc_hsv_segmentation(imagesrc, orange_segmentation, 6, 12, 68, 78, 80, 92);\par
200 \par
201                         {\cf19 for} ({\cf18 int} j = 0; j < 3; j++)\par
202                         \{\par
203 \par
204                             {\cf20 // compara imagem das faixas todas com a imagem das faixas verde}\par
205                             {\cf19 if} (comparePixelsAtPosition(resistance_bands_dilate, green_segmentation, blobs[i].yc, widths[j]))\par
206                             \{\par
207 \par
208                                 cores[j] = (j == 2) ? 100000 : 5;\par
209                             \}\par
210 \par
211                             {\cf20 // compara imagem das faixas todas com a imagem das faixas azul}\par
212                             {\cf19 if} (comparePixelsAtPosition(resistance_bands_dilate, blue_segmentation, blobs[i].yc, widths[j]))\par
213                             \{\par
214 \par
215                                 cores[j] = (j == 2) ? 1000000 : 6;\par
216                             \}\par
217 \par
218                             {\cf20 // compara imagem das faixas todas com a imagem das faixas vermelho}\par
219                             {\cf19 if} (comparePixelsAtPosition(resistance_bands_dilate, red_segmentation_dilate, blobs[i].yc, widths[j]))\par
220                             \{\par
221 \par
222                                 cores[j] = (j == 2) ? 100 : 2;\par
223                             \}\par
224 \par
225                             {\cf20 // compara imagem das faixas todas com a imagem das faixas castanho}\par
226                             {\cf19 if} (comparePixelsAtPosition(resistance_bands_dilate, brown_segmentation, blobs[i].yc, widths[j]))\par
227                             \{\par
228 \par
229                                 cores[j] = (j == 2) ? 10 : 1;\par
230                             \}\par
231 \par
232                             {\cf20 // compara imagem das faixas todas com a imagem das faixas preto}\par
233                             {\cf19 if} (comparePixelsAtPosition(resistance_bands_dilate, black_segmentation, blobs[i].yc, widths[j]))\par
234                             \{\par
235 \par
236                                 cores[j] = (j == 2) ? 1 : 0;\par
237                             \}\par
238 \par
239                             {\cf20 // compara imagem das faixas todas com a imagem das faixas laranja}\par
240                             {\cf19 if} (comparePixelsAtPosition(resistance_bands_dilate, orange_segmentation, blobs[i].yc, widths[j]))\par
241                             \{\par
242 \par
243                                 cores[j] = (j == 2) ? 1000 : 3;\par
244                             \}\par
245                         \}\par
246 \par
247                         {\cf19 if} (resistorIndex < 6)\par
248                         \{\par
249                             {\cf18 int} valor1 = cores[0];\par
250                             {\cf18 int} valor2 = cores[1];\par
251                             {\cf18 long} multiplicador = cores[2];\par
252 \par
253                             resistencias[resistorIndex] = (valor1 * 10 + valor2) * multiplicador;\par
254 \par
255                             resistorIndex++;\par
256                         \}\par
257                     \}\par
258                 \}\par
259             \}\par
260             free(blobs);\par
261         \}\par
262 \par
263         brancoparaoriginal_trabalho(final_image, resistances_labelled, imagesrc2);\par
264         memcpy(frame.data, final_image->data, video.width * video.height * 3);\par
265         std::string textCurrent = {\cf22 "Numero de Resistencias Atuais: "} + std::to_string(currentResistorCount);\par
266         {\cf18 int} fontFace = cv::FONT_HERSHEY_TRIPLEX;\par
267         {\cf18 double} fontScale = 0.5;\par
268         {\cf18 int} thickness = 1;\par
269         cv::Point textOrgCurrent(10, 50);\par
270         cv::putText(frame, textCurrent, textOrgCurrent, fontFace, fontScale, cv::Scalar(0, 0, 0), thickness, 8);\par
271 \par
272         std::string textTotal = {\cf22 "Numero total de Resistencias: "} + std::to_string(totalResistorCount);\par
273         {\cf18 int} fontFacee = cv::FONT_HERSHEY_TRIPLEX;\par
274         {\cf18 double} fontScalee = 0.5;\par
275         {\cf18 int} thicknesse = 1;\par
276         cv::Point textOrgTotal(10, 80);\par
277         cv::putText(frame, textTotal, textOrgTotal, fontFacee, fontScalee, cv::Scalar(0, 0, 255), thicknesse, 8);\par
278 \par
279         {\cf18 int} fontFaceee = cv::FONT_HERSHEY_TRIPLEX;\par
280         {\cf18 double} fontScaleee = 0.5;\par
281         {\cf18 int} thicknessee = 1;\par
282         cv::Point textOrgOhms(10, 110);\par
283 \par
284         std::string textOhms;\par
285         {\cf19 if} (resistorIndex > 0)\par
286         \{\par
287             textOhms = {\cf22 "Ohms da Resistencia Atual: "} + std::to_string(resistencias[resistorIndex - 1]) + {\cf22 " ohms"};\par
288         \}\par
289         {\cf19 else}\par
290         \{\par
291             textOhms = {\cf22 "Ohms da Resistencia Atual: --"};\par
292         \}\par
293         cv::putText(frame, textOhms, cv::Point(10, 110), cv::FONT_HERSHEY_TRIPLEX, 0.5, cv::Scalar(255, 0, 0), 1, 8);\par
294 \par
295         cv::imshow({\cf22 "VC - VIDEO"}, frame);\par
296 \par
297         {\cf20 // cv::Mat grayMat = IVC_to_Mat1Channel(orange_segmentation);}\par
298         {\cf20 // cv::imshow("VC - VIDEO", grayMat);}\par
299 \par
300         key = cv::waitKey(1);\par
301     \}\par
302 \par
303     vc_image_free(imagesrc);\par
304     vc_image_free(imagesrc2);\par
305     vc_image_free(green_segmentation);\par
306     vc_image_free(blue_segmentation);\par
307     vc_image_free(red_segmentation);\par
308     vc_image_free(brown_segmentation);\par
309     vc_image_free(black_segmentation);\par
310     vc_image_free(orange_segmentation);\par
311     vc_image_free(red_segmentation_dilate);\par
312     vc_image_free(image_resistances_segmentation);\par
313     vc_image_free(resistances_segmentation_dilate);\par
314     vc_image_free(resistances_labelled);\par
315     vc_image_free(final_image);\par
316     vc_image_free(resistance_bands_dilate);\par
317     vc_image_free(resistance_bands);\par
318 \par
319     {\cf20 /* Para o timer e exibe o tempo decorrido */}\par
320     vc_timer();\par
321 \par
322     {\cf20 /* Fecha a janela */}\par
323     cv::destroyWindow({\cf22 "VC - VIDEO"});\par
324 \par
325     {\cf20 /* Fecha o ficheiro de v\'EF\'BF\'BDdeo */}\par
326     capture.release();\par
327 \par
328     {\cf19 return} 0;\par
329 \}\par
}
}
{\xe \v vc_timer\:main.cpp}
{\xe \v main.cpp\:vc_timer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vc_timer (void )}}
\par
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15 \{\par
16     {\cf17 static} {\cf18 bool} running = {\cf17 false};\par
17     {\cf17 static} std::chrono::steady_clock::time_point previousTime = std::chrono::steady_clock::now();\par
18 \par
19     {\cf19 if} (!running)\par
20     \{\par
21         running = {\cf17 true};\par
22     \}\par
23     {\cf19 else}\par
24     \{\par
25         std::chrono::steady_clock::time_point currentTime = std::chrono::steady_clock::now();\par
26         std::chrono::steady_clock::duration elapsedTime = currentTime - previousTime;\par
27 \par
28         {\cf20 // Tempo em segundos.}\par
29         std::chrono::duration<double> time_span = std::chrono::duration_cast<std::chrono::duration<double>>(elapsedTime);\par
30         {\cf18 double} nseconds = time_span.count();\par
31 \par
32         std::cout << {\cf22 "Tempo decorrido: "} << nseconds << {\cf22 "segundos"} << std::endl;\par
33         std::cout << {\cf22 "Pressione qualquer tecla para continuar...\\n"};\par
34         std::cin.get();\par
35     \}\par
36 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Program Files (x86)/VisaoComputador_TP/CodigoFonte/vc.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Program Files (x86)/VisaoComputador_TP/CodigoFonte/vc.c}
{\xe \v C:/Program Files (x86)/VisaoComputador_TP/CodigoFonte/vc.c}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <ctype.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <malloc.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include <time.h>}\par
{\f2 #include "vc.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _CRT_SECURE_NO_WARNINGS}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IVC} * {\b vc_image_new} (int width, int height, int channels, int levels)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IVC} * {\b vc_image_free} ({\b IVC} *image)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b netpbm_get_token} (FILE *file, char *tok, int len)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
long int {\b unsigned_char_to_bit} (unsigned char *datauchar, unsigned char *databit, int width, int height)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b bit_to_unsigned_char} (unsigned char *databit, unsigned char *datauchar, int width, int height)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IVC} * {\b vc_read_image} (char *filename)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_write_image} (char *filename, {\b IVC} *image)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_gray_negative} ({\b IVC} *srcdst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_rgb_negative} ({\b IVC} *srcdst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_rgb_get_red_gray} ({\b IVC} *srcdst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_rgb_get_green_gray} ({\b IVC} *srcdst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_rgb_get_blue_gray} ({\b IVC} *srcdst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_rgb_to_gray} ({\b IVC} *src, {\b IVC} *dst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_rgb_to_hsv} ({\b IVC} *srcdst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_hsv_segmentation} ({\b IVC} *src, {\b IVC} *dst, int hmin, int hmax, int smin, int smax, int vmin, int vmax)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_scale_gray_to_rgb} ({\b IVC} *src, {\b IVC} *dst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b combine_segmentations} ({\b IVC} *dst, {\b IVC} *src1, {\b IVC} *src2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_white_pixels_quantitie} ({\b IVC} *srcdst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_gray_to_binary} ({\b IVC} *srcdst, int threshold)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_gray_to_binary_global_mean} ({\b IVC} *srcdst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_gray_to_binary_midpoint} ({\b IVC} *src, {\b IVC} *dst, int kernel)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_gray_to_binary_bernsen} ({\b IVC} *src, {\b IVC} *dst, int kernel, int cmin)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_gray_to_binary_niblack} ({\b IVC} *src, {\b IVC} *dst, int kernel, float k)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_binary_dilate} ({\b IVC} *src, {\b IVC} *dst, int kernel)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_binary_erode} ({\b IVC} *src, {\b IVC} *dst, int kernel)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_binary_open} ({\b IVC} *src, {\b IVC} *dst, int kernel)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_binary_close} ({\b IVC} *src, {\b IVC} *dst, int kernel)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_gray_dilate} ({\b IVC} *src, {\b IVC} *dst, int kernel)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_gray_erode} ({\b IVC} *src, {\b IVC} *dst, int kernel)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_gray_open} ({\b IVC} *src, {\b IVC} *dst, int kernel)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_gray_close} ({\b IVC} *src, {\b IVC} *dst, int kernel)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b combine_segmentations2} ({\b IVC} *dst, {\b IVC} *src1, {\b IVC} *src2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b brancoparaoriginal} ({\b IVC} *dst, {\b IVC} *src1, {\b IVC} *src2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b OVC} * {\b vc_binary_blob_labelling} ({\b IVC} *src, {\b IVC} *dst, int *nlabels)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_binary_blob_info} ({\b IVC} *src, {\b OVC} *blobs, int nblobs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_coloring} ({\b IVC} *src, {\b IVC} *dst, int nlabels)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_draw_boundingbox} ({\b IVC} *srcdst, {\b OVC} *blobs, int nblobs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_draw_centerofgravity} ({\b IVC} *srcdst, {\b OVC} *blobs, int nblobs, int s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_gray_histogram_show} ({\b IVC} *src, {\b IVC} *dst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_gray_histogram_equalization} ({\b IVC} *src, {\b IVC} *dst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_gray_edge_prewitt} ({\b IVC} *src, {\b IVC} *dst, float th)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_bgr_to_rgb} ({\b IVC} *srcdst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_bgr_to_hsv} ({\b IVC} *srcdst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b brancoparaoriginal_trabalho} ({\b IVC} *dst, {\b IVC} *src1, {\b IVC} *src2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_hsv_segmentation_vermelho} ({\b IVC} *src, {\b IVC} *dst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_hsv_segmentation_castanho} ({\b IVC} *src, {\b IVC} *dst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_hsv_segmentation_final} ({\b IVC} *src, {\b IVC} *dst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_hsv_segmentation_resistencias} ({\b IVC} *src, {\b IVC} *dst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lookForWhite} ({\b IVC} *src, int yc, int *widths)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b comparePixelsAtPosition} ({\b IVC} *src1, {\b IVC} *src2, int yc, int width)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_bgr_to_hsv2} ({\b IVC} *src, {\b IVC} *dst)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v _CRT_SECURE_NO_WARNINGS\:vc.c}
{\xe \v vc.c\:_CRT_SECURE_NO_WARNINGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _CRT_SECURE_NO_WARNINGS}}
\par
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v bit_to_unsigned_char\:vc.c}
{\xe \v vc.c\:bit_to_unsigned_char}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void bit_to_unsigned_char (unsigned char *  {\i databit}, unsigned char *  {\i datauchar}, int  {\i width}, int  {\i height})}}
\par
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 155 \{\par
156     {\cf18 int} x, y;\par
157     {\cf18 int} countbits;\par
158     {\cf18 long} {\cf18 int} pos;\par
159     {\cf18 unsigned} {\cf18 char} *p = databit;\par
160 \par
161     countbits = 1;\par
162 \par
163     {\cf19 for} (y = 0; y < height; y++)\par
164     \{\par
165         {\cf19 for} (x = 0; x < width; x++)\par
166         \{\par
167             pos = width * y + x;\par
168 \par
169             {\cf19 if} (countbits <= 8)\par
170             \{\par
171                 {\cf20 // Numa imagem PBM:}\par
172                 {\cf20 // 1 = Preto}\par
173                 {\cf20 // 0 = Branco}\par
174                 {\cf20 // datauchar[pos] = (*p & (1 << (8 - countbits))) ? 1 : 0;}\par
175 \par
176                 {\cf20 // Na nossa imagem:}\par
177                 {\cf20 // 1 = Branco}\par
178                 {\cf20 // 0 = Preto}\par
179                 datauchar[pos] = (*p & (1 << (8 - countbits))) ? 0 : 1;\par
180 \par
181                 countbits++;\par
182             \}\par
183             {\cf19 if} ((countbits > 8) || (x == width - 1))\par
184             \{\par
185                 p++;\par
186                 countbits = 1;\par
187             \}\par
188         \}\par
189     \}\par
190 \}\par
}
}
{\xe \v brancoparaoriginal\:vc.c}
{\xe \v vc.c\:brancoparaoriginal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void brancoparaoriginal ({\b IVC} *  {\i dst}, {\b IVC} *  {\i src1}, {\b IVC} *  {\i src2})}}
\par
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1375 \{\par
1376     {\cf19 if} (src1->width != src2->width || src1->height != src2->height)\par
1377     \{\par
1378         printf({\cf22 "ERROR -> combine_segmentations():\\n\\tImages size mismatch!\\n"});\par
1379         {\cf19 return};\par
1380     \}\par
1381 \par
1382     {\cf19 for} ({\cf18 int} y = 0; y < src1->height; y++)\par
1383     \{\par
1384         {\cf19 for} ({\cf18 int} x = 0; x < src1->width; x++)\par
1385         \{\par
1386             {\cf18 int} pos = y * (src1->width) + x; {\cf20 // Assume imagens de destino s\'E3o monocrom\'E1ticas}\par
1387 \par
1388             {\cf19 if} (src1->data[pos] == 255)\par
1389             \{\par
1390                 dst->data[pos] = src2->data[pos];\par
1391             \}\par
1392             {\cf19 else}\par
1393             \{\par
1394                 dst->data[pos] = 0;\par
1395             \}\par
1396         \}\par
1397     \}\par
1398 \}\par
}
}
{\xe \v brancoparaoriginal_trabalho\:vc.c}
{\xe \v vc.c\:brancoparaoriginal_trabalho}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void brancoparaoriginal_trabalho ({\b IVC} *  {\i dst}, {\b IVC} *  {\i src1}, {\b IVC} *  {\i src2})}}
\par
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2172 \{\par
2173     {\cf19 if} (src1->width != src2->width || src1->height != src2->height)\par
2174     \{\par
2175         printf({\cf22 "ERROR -> brancoparaoriginal_trabalho():\\n\\tImages size mismatch!\\n"});\par
2176         {\cf19 return};\par
2177     \}\par
2178 \par
2179     {\cf19 if} (src1->channels != 1 || src2->channels != 3 || dst->channels != 3)\par
2180     \{\par
2181         printf({\cf22 "ERROR -> brancoparaoriginal_trabalho():\\n\\tChannel number mismatch!\\n"});\par
2182         {\cf19 return};\par
2183     \}\par
2184 \par
2185     {\cf18 int} start = 150;\par
2186     {\cf18 int} end = src1->width - 150;\par
2187 \par
2188     {\cf19 for} ({\cf18 int} y = 0; y < src1->height; y++)\par
2189     \{\par
2190         {\cf19 for} ({\cf18 int} x = 0; x < src1->width; x++)\par
2191         \{\par
2192             {\cf18 int} posSrc1 = y * src1->bytesperline + x;     {\cf20 // Position in the binary image}\par
2193             {\cf18 int} posSrc2 = y * src2->bytesperline + 3 * x; {\cf20 // Position in the 3-channel image}\par
2194 \par
2195             {\cf19 if} (x >= start && x < end)\par
2196             \{\par
2197                 {\cf19 if} (src1->data[posSrc1] == 255)\par
2198                 \{\par
2199                     {\cf20 // Set dst pixels to white if src1's corresponding pixel is 255 within specified range}\par
2200                     dst->data[posSrc2] = 255;\par
2201                     dst->data[posSrc2 + 1] = 255;\par
2202                     dst->data[posSrc2 + 2] = 255;\par
2203                 \}\par
2204                 {\cf19 else}\par
2205                 \{\par
2206                     {\cf20 // Copy pixel from src2 to dst within specified range}\par
2207                     dst->data[posSrc2] = src2->data[posSrc2];\par
2208                     dst->data[posSrc2 + 1] = src2->data[posSrc2 + 1];\par
2209                     dst->data[posSrc2 + 2] = src2->data[posSrc2 + 2];\par
2210                 \}\par
2211             \}\par
2212             {\cf19 else}\par
2213             \{\par
2214                 {\cf20 // Copy pixel from src2 to dst outside specified range}\par
2215                 dst->data[posSrc2] = src2->data[posSrc2];\par
2216                 dst->data[posSrc2 + 1] = src2->data[posSrc2 + 1];\par
2217                 dst->data[posSrc2 + 2] = src2->data[posSrc2 + 2];\par
2218             \}\par
2219         \}\par
2220     \}\par
2221 \}\par
}
}
{\xe \v combine_segmentations\:vc.c}
{\xe \v vc.c\:combine_segmentations}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void combine_segmentations ({\b IVC} *  {\i dst}, {\b IVC} *  {\i src1}, {\b IVC} *  {\i src2})}}
\par
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 752 \{\par
753     {\cf19 if} (src1->width != src2->width || src1->height != src2->height)\par
754     \{\par
755         printf({\cf22 "ERROR -> combine_segmentations():\\n\\tImages size mismatch!\\n"});\par
756         {\cf19 return};\par
757     \}\par
758 \par
759     {\cf19 for} ({\cf18 int} y = 0; y < src1->height; y++)\par
760     \{\par
761         {\cf19 for} ({\cf18 int} x = 0; x < src1->width; x++)\par
762         \{\par
763             {\cf18 int} pos = y * (src1->width) + x; {\cf20 // Assume imagens de destino s\'E3o monocrom\'E1ticas}\par
764 \par
765             {\cf20 // Se algum dos pixels nas imagens tempor\'E1rias for branco, defina o correspondente em dst como branco}\par
766             {\cf19 if} (src1->data[pos] == 255 || src2->data[pos] == 255)\par
767             \{\par
768                 dst->data[pos] = 255;\par
769             \}\par
770             {\cf19 else}\par
771             \{\par
772                 dst->data[pos] = 0;\par
773             \}\par
774         \}\par
775     \}\par
776 \}\par
}
}
{\xe \v combine_segmentations2\:vc.c}
{\xe \v vc.c\:combine_segmentations2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void combine_segmentations2 ({\b IVC} *  {\i dst}, {\b IVC} *  {\i src1}, {\b IVC} *  {\i src2})}}
\par
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1344 \{\par
1345     {\cf19 if} (src1->width != src2->width || src1->height != src2->height)\par
1346     \{\par
1347         printf({\cf22 "ERROR -> combine_segmentations():\\n\\tImages size mismatch!\\n"});\par
1348         {\cf19 return};\par
1349     \}\par
1350 \par
1351     {\cf19 for} ({\cf18 int} y = 0; y < src1->height; y++)\par
1352     \{\par
1353         {\cf19 for} ({\cf18 int} x = 0; x < src1->width; x++)\par
1354         \{\par
1355             {\cf18 int} pos = y * (src1->width) + x; {\cf20 // Assume imagens de destino s\'E3o monocrom\'E1ticas}\par
1356 \par
1357             {\cf20 // Se algum dos pixels nas imagens tempor\'E1rias for branco, defina o correspondente em dst como branco}\par
1358 \par
1359             dst->data[pos] = src1->data[pos] - src2->data[pos];\par
1360 \par
1361             {\cf19 if} (dst->data[pos] > 255)\par
1362             \{\par
1363                 dst->data[pos] = 255;\par
1364             \}\par
1365 \par
1366             {\cf19 if} (dst->data[pos] < 0)\par
1367             \{\par
1368                 dst->data[pos] = 0;\par
1369             \}\par
1370         \}\par
1371     \}\par
1372 \}\par
}
}
{\xe \v comparePixelsAtPosition\:vc.c}
{\xe \v vc.c\:comparePixelsAtPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int comparePixelsAtPosition ({\b IVC} *  {\i src1}, {\b IVC} *  {\i src2}, int  {\i yc}, int  {\i width})}}
\par
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2476 \{\par
2477     {\cf18 unsigned} {\cf18 char} *data1 = ({\cf18 unsigned} {\cf18 char} *)src1->data;\par
2478     {\cf18 unsigned} {\cf18 char} *data2 = ({\cf18 unsigned} {\cf18 char} *)src2->data;\par
2479     {\cf18 int} bytesperline = src1->bytesperline;\par
2480     {\cf18 int} channels = src1->channels;\par
2481 \par
2482     {\cf18 long} {\cf18 int} pos = yc * bytesperline + width * channels;\par
2483 \par
2484     {\cf19 if} (data1[pos] == data2[pos])\par
2485     \{\par
2486         {\cf19 return} 1;\par
2487     \}\par
2488     {\cf19 return} 0;\par
2489 \}\par
}
}
{\xe \v lookForWhite\:vc.c}
{\xe \v vc.c\:lookForWhite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lookForWhite ({\b IVC} *  {\i src}, int  {\i yc}, int *  {\i widths})}}
\par
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2420 \{\par
2421     {\cf18 unsigned} {\cf18 char} *data = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
2422     {\cf18 int} width = src->width;\par
2423     {\cf18 int} bytesperline = src->bytesperline;\par
2424     {\cf18 int} channels = src->channels;\par
2425     {\cf18 int} x;\par
2426     {\cf18 long} {\cf18 int} pos;\par
2427 \par
2428     if ((src->width <= 0) || (src->height <= 0) || (src->data == NULL))\par
2429         {\cf19 return};\par
2430 \par
2431     {\cf19 if} (yc < 0 || yc >= src->height) {\cf20 // Ensure yc is within bounds}\par
2432         {\cf19 return};\par
2433 \par
2434     {\cf18 int} state = 0; {\cf20 // 0: looking for first white, 1: looking for transition to black, 2: looking for next white after black}\par
2435     {\cf18 int} count = 0;\par
2436 \par
2437     {\cf19 for} (x = 0; x < width; x++)\par
2438     \{\par
2439         pos = yc * bytesperline + x * channels;\par
2440 \par
2441         {\cf19 if} (state == 0)\par
2442         \{\par
2443             {\cf19 if} (data[pos] == 255)\par
2444             \{\par
2445                 {\cf19 if} (count < 3)\par
2446                 \{\par
2447                     widths[count++] = x + 4;\par
2448                 \}\par
2449 \par
2450                 state = 1;\par
2451             \}\par
2452         \}\par
2453         {\cf19 else} {\cf19 if} (state == 1)\par
2454         \{\par
2455             {\cf19 if} (data[pos] == 0)\par
2456             \{\par
2457                 state = 2;\par
2458             \}\par
2459         \}\par
2460         {\cf19 else} {\cf19 if} (state == 2)\par
2461         \{\par
2462             {\cf19 if} (data[pos] == 255)\par
2463             \{\par
2464                 {\cf19 if} (count < 3)\par
2465                 \{\par
2466                     widths[count++] = x + 4;\par
2467                 \}\par
2468 \par
2469                 state = 1;\par
2470             \}\par
2471         \}\par
2472     \}\par
2473 \}\par
}
}
{\xe \v netpbm_get_token\:vc.c}
{\xe \v vc.c\:netpbm_get_token}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char * netpbm_get_token (FILE *  {\i file}, char *  {\i tok}, int  {\i len})}}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 74 \{\par
75     {\cf18 char} *t;\par
76     {\cf18 int} c;\par
77 \par
78     {\cf19 for} (;;)\par
79     \{\par
80         {\cf19 while} (isspace(c = getc(file)))\par
81             ;\par
82         {\cf19 if} (c != {\cf23 '#'})\par
83             {\cf19 break};\par
84         {\cf19 do}\par
85             c = getc(file);\par
86         {\cf19 while} ((c != {\cf23 '\\n'}) && (c != EOF));\par
87         {\cf19 if} (c == EOF)\par
88             {\cf19 break};\par
89     \}\par
90 \par
91     t = tok;\par
92 \par
93     {\cf19 if} (c != EOF)\par
94     \{\par
95         {\cf19 do}\par
96         \{\par
97             *t++ = c;\par
98             c = getc(file);\par
99         \} {\cf19 while} ((!isspace(c)) && (c != {\cf23 '#'}) && (c != EOF) && (t - tok < len - 1));\par
100 \par
101         {\cf19 if} (c == {\cf23 '#'})\par
102             ungetc(c, file);\par
103     \}\par
104 \par
105     *t = 0;\par
106 \par
107     {\cf19 return} tok;\par
108 \}\par
}
}
{\xe \v unsigned_char_to_bit\:vc.c}
{\xe \v vc.c\:unsigned_char_to_bit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
long int unsigned_char_to_bit (unsigned char *  {\i datauchar}, unsigned char *  {\i databit}, int  {\i width}, int  {\i height})}}
\par
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 111 \{\par
112     {\cf18 int} x, y;\par
113     {\cf18 int} countbits;\par
114     {\cf18 long} {\cf18 int} pos, counttotalbytes;\par
115     {\cf18 unsigned} {\cf18 char} *p = databit;\par
116 \par
117     *p = 0;\par
118     countbits = 1;\par
119     counttotalbytes = 0;\par
120 \par
121     {\cf19 for} (y = 0; y < height; y++)\par
122     \{\par
123         {\cf19 for} (x = 0; x < width; x++)\par
124         \{\par
125             pos = width * y + x;\par
126 \par
127             {\cf19 if} (countbits <= 8)\par
128             \{\par
129                 {\cf20 // Numa imagem PBM:}\par
130                 {\cf20 // 1 = Preto}\par
131                 {\cf20 // 0 = Branco}\par
132                 {\cf20 //*p |= (datauchar[pos] != 0) << (8 - countbits);}\par
133 \par
134                 {\cf20 // Na nossa imagem:}\par
135                 {\cf20 // 1 = Branco}\par
136                 {\cf20 // 0 = Preto}\par
137                 *p |= (datauchar[pos] == 0) << (8 - countbits);\par
138 \par
139                 countbits++;\par
140             \}\par
141             {\cf19 if} ((countbits > 8) || (x == width - 1))\par
142             \{\par
143                 p++;\par
144                 *p = 0;\par
145                 countbits = 1;\par
146                 counttotalbytes++;\par
147             \}\par
148         \}\par
149     \}\par
150 \par
151     {\cf19 return} counttotalbytes;\par
152 \}\par
}
}
{\xe \v vc_bgr_to_hsv\:vc.c}
{\xe \v vc.c\:vc_bgr_to_hsv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_bgr_to_hsv ({\b IVC} *  {\i srcdst})}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2097 \{\par
2098     {\cf18 unsigned} {\cf18 char} *data = ({\cf18 unsigned} {\cf18 char} *)srcdst->data;\par
2099     {\cf18 int} width = srcdst->width;\par
2100     {\cf18 int} height = srcdst->height;\par
2101     {\cf18 int} bytesperline = srcdst->bytesperline;\par
2102     {\cf18 int} channels = srcdst->channels;\par
2103     {\cf18 float} r, g, b, saturation, hue, value;\par
2104     {\cf18 int} i, size;\par
2105     {\cf18 int} pos_src;\par
2106     {\cf18 float} rgb_max;\par
2107     {\cf18 float} rgb_min;\par
2108 \par
2109     if ((srcdst->width <= 0) || (srcdst->height <= 0) || (srcdst->data == NULL))\par
2110         {\cf19 return} 0;\par
2111     {\cf19 if} (channels != 3)\par
2112         {\cf19 return} 0;\par
2113 \par
2114     size = width * height * channels;\par
2115 \par
2116     {\cf19 for} (i = 0; i < size; i += channels)\par
2117     \{\par
2118         pos_src = i;\par
2119 \par
2120         b = (float)data[pos_src];\par
2121         g = (float)data[pos_src + 1];\par
2122         r = (float)data[pos_src + 2];\par
2123 \par
2124         rgb_max = fmaxf(r, fmaxf(g, b));\par
2125         rgb_min = fminf(r, fminf(g, b));\par
2126 \par
2127         value = rgb_max;\par
2128 \par
2129         {\cf19 if} (value == 0.0f)\par
2130         \{\par
2131             hue = 0.0f;\par
2132             saturation = 0.0f;\par
2133         \}\par
2134         {\cf19 else}\par
2135         \{\par
2136             saturation = ((rgb_max - rgb_min) / rgb_max) * 255.0f;\par
2137 \par
2138             {\cf19 if} (saturation == 0.0f)\par
2139             \{\par
2140                 hue = 0.0f;\par
2141             \}\par
2142             {\cf19 else}\par
2143             \{\par
2144                 {\cf19 if} ((rgb_max == r) && (g >= b))\par
2145                 \{\par
2146                     hue = 60.0f * (g - b) / (rgb_max - rgb_min);\par
2147                 \}\par
2148                 {\cf19 else} {\cf19 if} ((rgb_max == r) && (b > g))\par
2149                 \{\par
2150                     hue = 360.0f + 60.0f * (g - b) / (rgb_max - rgb_min);\par
2151                 \}\par
2152                 {\cf19 else} {\cf19 if} (rgb_max == g)\par
2153                 \{\par
2154                     hue = 120.0f + 60.0f * (b - r) / (rgb_max - rgb_min);\par
2155                 \}\par
2156                 {\cf19 else} {\cf19 if} (rgb_max == b)\par
2157                 \{\par
2158                     hue = 240.0f + 60.0f * (r - g) / (rgb_max - rgb_min);\par
2159                 \}\par
2160             \}\par
2161         \}\par
2162 \par
2163         data[i] = ({\cf18 unsigned} char)(hue / 360.0f * 255.0f);\par
2164         data[i + 1] = ({\cf18 unsigned} char)(saturation);\par
2165         data[i + 2] = ({\cf18 unsigned} char)(value);\par
2166     \}\par
2167 \par
2168     {\cf19 return} 1;\par
2169 \}\par
}
}
{\xe \v vc_bgr_to_hsv2\:vc.c}
{\xe \v vc.c\:vc_bgr_to_hsv2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_bgr_to_hsv2 ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst})}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2492 \{\par
2493     {\cf18 unsigned} {\cf18 char} *data_src = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
2494     {\cf18 unsigned} {\cf18 char} *data_dst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
2495     {\cf18 int} width = src->width;\par
2496     {\cf18 int} height = src->height;\par
2497     {\cf18 int} bytesperline = src->bytesperline;\par
2498     {\cf18 int} channels = src->channels;\par
2499     {\cf18 float} r, g, b, saturation, hue, value;\par
2500     {\cf18 int} i, size;\par
2501     {\cf18 int} pos_src, pos_dst;\par
2502     {\cf18 float} rgb_max;\par
2503     {\cf18 float} rgb_min;\par
2504 \par
2505     {\cf19 if} ((src->width <= 0) || (src->height <= 0) || (src->data == NULL))\par
2506         {\cf19 return} 0;\par
2507     {\cf19 if} (channels != 3 || dst->channels != 3)\par
2508         {\cf19 return} 0;\par
2509 \par
2510     size = width * height * channels;\par
2511 \par
2512     {\cf19 for} (i = 0; i < size; i += channels)\par
2513     \{\par
2514         pos_src = i;\par
2515         pos_dst = i;\par
2516 \par
2517         b = (float)data_src[pos_src];\par
2518         g = (float)data_src[pos_src + 1];\par
2519         r = (float)data_src[pos_src + 2];\par
2520 \par
2521         rgb_max = fmaxf(r, fmaxf(g, b));\par
2522         rgb_min = fminf(r, fminf(g, b));\par
2523 \par
2524         value = rgb_max;\par
2525 \par
2526         {\cf19 if} (value == 0.0f)\par
2527         \{\par
2528             hue = 0.0f;\par
2529             saturation = 0.0f;\par
2530         \}\par
2531         {\cf19 else}\par
2532         \{\par
2533             saturation = ((rgb_max - rgb_min) / rgb_max) * 255.0f;\par
2534 \par
2535             {\cf19 if} (saturation == 0.0f)\par
2536             \{\par
2537                 hue = 0.0f;\par
2538             \}\par
2539             {\cf19 else}\par
2540             \{\par
2541                 {\cf19 if} ((rgb_max == r) && (g >= b))\par
2542                 \{\par
2543                     hue = 60.0f * (g - b) / (rgb_max - rgb_min);\par
2544                 \}\par
2545                 {\cf19 else} {\cf19 if} ((rgb_max == r) && (b > g))\par
2546                 \{\par
2547                     hue = 360.0f + 60.0f * (g - b) / (rgb_max - rgb_min);\par
2548                 \}\par
2549                 {\cf19 else} {\cf19 if} (rgb_max == g)\par
2550                 \{\par
2551                     hue = 120.0f + 60.0f * (b - r) / (rgb_max - rgb_min);\par
2552                 \}\par
2553                 {\cf19 else} {\cf19 if} (rgb_max == b)\par
2554                 \{\par
2555                     hue = 240.0f + 60.0f * (r - g) / (rgb_max - rgb_min);\par
2556                 \}\par
2557             \}\par
2558         \}\par
2559 \par
2560         data_dst[pos_dst] = ({\cf18 unsigned} char)(hue / 360.0f * 255.0f);\par
2561         data_dst[pos_dst + 1] = ({\cf18 unsigned} char)(saturation);\par
2562         data_dst[pos_dst + 2] = ({\cf18 unsigned} char)(value);\par
2563     \}\par
2564 \par
2565     {\cf19 return} 1;\par
2566 \}\par
}
}
{\xe \v vc_bgr_to_rgb\:vc.c}
{\xe \v vc.c\:vc_bgr_to_rgb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_bgr_to_rgb ({\b IVC} *  {\i srcdst})}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2069 \{\par
2070     {\cf19 if} (srcdst == NULL)\par
2071         {\cf19 return} 0;\par
2072     {\cf19 if} (srcdst->channels != 3)\par
2073         {\cf19 return} 0;\par
2074 \par
2075     {\cf18 unsigned} {\cf18 char} temp;\par
2076     {\cf18 int} width = srcdst->width;\par
2077     {\cf18 int} height = srcdst->height;\par
2078     {\cf18 int} bytesperline = srcdst->bytesperline;\par
2079     {\cf18 int} channels = srcdst->channels;\par
2080     {\cf18 unsigned} {\cf18 char} *data = srcdst->data;\par
2081 \par
2082     {\cf19 for} ({\cf18 int} y = 0; y < height; y++)\par
2083     \{\par
2084         {\cf19 for} ({\cf18 int} x = 0; x < width; x++)\par
2085         \{\par
2086             {\cf18 int} pos = y * bytesperline + x * channels;\par
2087 \par
2088             temp = data[pos];\par
2089             data[pos] = data[pos + 2];\par
2090             data[pos + 2] = temp;\par
2091         \}\par
2092     \}\par
2093     {\cf19 return} 1;\par
2094 \}\par
}
}
{\xe \v vc_binary_blob_info\:vc.c}
{\xe \v vc.c\:vc_binary_blob_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_binary_blob_info ({\b IVC} *  {\i src}, {\b OVC} *  {\i blobs}, int  {\i nblobs})}}
\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1608 \{\par
1609     {\cf18 unsigned} {\cf18 char} *data = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
1610     {\cf18 int} width = src->width;\par
1611     {\cf18 int} height = src->height;\par
1612     {\cf18 int} bytesperline = src->bytesperline;\par
1613     {\cf18 int} channels = src->channels;\par
1614     {\cf18 int} x, y, i;\par
1615     {\cf18 long} {\cf18 int} pos;\par
1616     {\cf18 int} xmin, ymin, xmax, ymax;\par
1617     {\cf18 long} {\cf18 int} sumx, sumy;\par
1618 \par
1619     {\cf20 // Verifica\'EF\'BF\'BD\'EF\'BF\'BDo de erros}\par
1620     if ((src->width <= 0) || (src->height <= 0) || (src->data == NULL))\par
1621         {\cf19 return} 0;\par
1622     {\cf19 if} (channels != 1)\par
1623         {\cf19 return} 0;\par
1624 \par
1625     {\cf20 // Conta \'EF\'BF\'BDrea de cada blob}\par
1626     {\cf19 for} (i = 0; i < nblobs; i++)\par
1627     \{\par
1628         xmin = width - 1;\par
1629         ymin = height - 1;\par
1630         xmax = 0;\par
1631         ymax = 0;\par
1632 \par
1633         sumx = 0;\par
1634         sumy = 0;\par
1635 \par
1636         blobs[i].area = 0;\par
1637 \par
1638         {\cf19 for} (y = 1; y < height - 1; y++)\par
1639         \{\par
1640             {\cf19 for} (x = 1; x < width - 1; x++)\par
1641             \{\par
1642                 pos = y * bytesperline + x * channels;\par
1643 \par
1644                 {\cf19 if} (data[pos] == blobs[i].label)\par
1645                 \{\par
1646                     {\cf20 // \'EF\'BF\'BDrea}\par
1647                     blobs[i].area++;\par
1648 \par
1649                     {\cf20 // Centro de Gravidade}\par
1650                     sumx += x;\par
1651                     sumy += y;\par
1652 \par
1653                     {\cf20 // Bounding Box}\par
1654                     {\cf19 if} (xmin > x)\par
1655                         xmin = x;\par
1656                     {\cf19 if} (ymin > y)\par
1657                         ymin = y;\par
1658                     {\cf19 if} (xmax < x)\par
1659                         xmax = x;\par
1660                     {\cf19 if} (ymax < y)\par
1661                         ymax = y;\par
1662 \par
1663                     {\cf20 // Per\'EF\'BF\'BDmetro}\par
1664                     {\cf20 // Se pelo menos um dos quatro vizinhos n\'EF\'BF\'BDo pertence ao mesmo label, ent\'EF\'BF\'BDo \'EF\'BF\'BD um pixel de contorno}\par
1665                     {\cf19 if} ((data[pos - 1] != blobs[i].label) || (data[pos + 1] != blobs[i].label) || (data[pos - bytesperline] != blobs[i].label) || (data[pos + bytesperline] != blobs[i].label))\par
1666                     \{\par
1667                         blobs[i].perimeter++;\par
1668                     \}\par
1669                 \}\par
1670             \}\par
1671         \}\par
1672 \par
1673         {\cf20 // Bounding Box}\par
1674         blobs[i].x = xmin;\par
1675         blobs[i].y = ymin;\par
1676         blobs[i].width = (xmax - xmin) + 1;\par
1677         blobs[i].height = (ymax - ymin) + 1;\par
1678 \par
1679         {\cf20 // Centro de Gravidade}\par
1680         {\cf20 // blobs[i].xc = (xmax - xmin) / 2;}\par
1681         {\cf20 // blobs[i].yc = (ymax - ymin) / 2;}\par
1682         blobs[i].xc = sumx / MY_MAX(blobs[i].area, 1);\par
1683         blobs[i].yc = sumy / MY_MAX(blobs[i].area, 1);\par
1684     \}\par
1685 \par
1686     {\cf19 return} 1;\par
1687 \}\par
}
}
{\xe \v vc_binary_blob_labelling\:vc.c}
{\xe \v vc.c\:vc_binary_blob_labelling}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b OVC} * vc_binary_blob_labelling ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst}, int *  {\i nlabels})}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1401 \{\par
1402     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
1403     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
1404     {\cf18 int} width = src->width;\par
1405     {\cf18 int} height = src->height;\par
1406     {\cf18 int} bytesperline = src->bytesperline;\par
1407     {\cf18 int} channels = src->channels;\par
1408     {\cf18 int} x, y, a, b;\par
1409     {\cf18 long} {\cf18 int} i, size;\par
1410     {\cf18 long} {\cf18 int} posX, posA, posB, posC, posD;\par
1411     {\cf18 int} labeltable[256] = \{0\};\par
1412     {\cf18 int} labelarea[256] = \{0\};\par
1413     {\cf18 int} label = 1; {\cf20 // Etiqueta inicial.}\par
1414     {\cf18 int} num, tmplabel;\par
1415     OVC *blobs; {\cf20 // Apontador para array de blobs (objectos) que ser\'EF\'BF\'BD retornado desta fun\'EF\'BF\'BD\'EF\'BF\'BDo.}\par
1416 \par
1417     {\cf20 // Verifica\'EF\'BF\'BD\'EF\'BF\'BDo de erros}\par
1418     {\cf19 if} ((src->width <= 0) || (src->height <= 0) || (src->data == NULL))\par
1419         {\cf19 return} 0;\par
1420     {\cf19 if} ((src->width != dst->width) || (src->height != dst->height) || (src->channels != dst->channels))\par
1421         {\cf19 return} NULL;\par
1422     {\cf19 if} (channels != 1)\par
1423         {\cf19 return} NULL;\par
1424 \par
1425     {\cf20 // Copia dados da imagem bin\'EF\'BF\'BDria para imagem grayscale}\par
1426     memcpy(datadst, datasrc, bytesperline * height);\par
1427 \par
1428     {\cf20 // Todos os pix\'EF\'BF\'BDis de plano de fundo devem obrigat\'EF\'BF\'BDriamente ter valor 0}\par
1429     {\cf20 // Todos os pix\'EF\'BF\'BDis de primeiro plano devem obrigat\'EF\'BF\'BDriamente ter valor 255}\par
1430     {\cf20 // Ser\'EF\'BF\'BDo atribu\'EF\'BF\'BDdas etiquetas no intervalo [1,254]}\par
1431     {\cf20 // Este algoritmo est\'EF\'BF\'BD assim limitado a 254 labels}\par
1432     {\cf19 for} (i = 0, size = bytesperline * height; i < size; i++)\par
1433     \{\par
1434         {\cf19 if} (datadst[i] != 0)\par
1435             datadst[i] = 255;\par
1436     \}\par
1437 \par
1438     {\cf20 // Limpa os rebordos da imagem bin\'EF\'BF\'BDria}\par
1439     {\cf19 for} (y = 0; y < height; y++)\par
1440     \{\par
1441         datadst[y * bytesperline + 0 * channels] = 0;\par
1442         datadst[y * bytesperline + (width - 1) * channels] = 0;\par
1443     \}\par
1444     {\cf19 for} (x = 0; x < width; x++)\par
1445     \{\par
1446         datadst[0 * bytesperline + x * channels] = 0;\par
1447         datadst[(height - 1) * bytesperline + x * channels] = 0;\par
1448     \}\par
1449 \par
1450     {\cf20 // Efectua a etiquetagem}\par
1451     {\cf19 for} (y = 1; y < height - 1; y++)\par
1452     \{\par
1453         {\cf19 for} (x = 1; x < width - 1; x++)\par
1454         \{\par
1455             {\cf20 // Kernel:}\par
1456             {\cf20 // A B C}\par
1457             {\cf20 // D X}\par
1458 \par
1459             posA = (y - 1) * bytesperline + (x - 1) * channels; {\cf20 // A}\par
1460             posB = (y - 1) * bytesperline + x * channels;       {\cf20 // B}\par
1461             posC = (y - 1) * bytesperline + (x + 1) * channels; {\cf20 // C}\par
1462             posD = y * bytesperline + (x - 1) * channels;       {\cf20 // D}\par
1463             posX = y * bytesperline + x * channels;             {\cf20 // X}\par
1464 \par
1465             {\cf20 // Se o pixel foi marcado}\par
1466             {\cf19 if} (datadst[posX] != 0)\par
1467             \{\par
1468                 {\cf19 if} ((datadst[posA] == 0) && (datadst[posB] == 0) && (datadst[posC] == 0) && (datadst[posD] == 0))\par
1469                 \{\par
1470                     datadst[posX] = label;\par
1471                     labeltable[label] = label;\par
1472                     label++;\par
1473                 \}\par
1474                 {\cf19 else}\par
1475                 \{\par
1476                     num = 255;\par
1477 \par
1478                     {\cf20 // Se A est\'EF\'BF\'BD marcado}\par
1479                     {\cf19 if} (datadst[posA] != 0)\par
1480                         num = labeltable[datadst[posA]];\par
1481                     {\cf20 // Se B est\'EF\'BF\'BD marcado, e \'EF\'BF\'BD menor que a etiqueta "num"}\par
1482                     {\cf19 if} ((datadst[posB] != 0) && (labeltable[datadst[posB]] < num))\par
1483                         num = labeltable[datadst[posB]];\par
1484                     {\cf20 // Se C est\'EF\'BF\'BD marcado, e \'EF\'BF\'BD menor que a etiqueta "num"}\par
1485                     {\cf19 if} ((datadst[posC] != 0) && (labeltable[datadst[posC]] < num))\par
1486                         num = labeltable[datadst[posC]];\par
1487                     {\cf20 // Se D est\'EF\'BF\'BD marcado, e \'EF\'BF\'BD menor que a etiqueta "num"}\par
1488                     {\cf19 if} ((datadst[posD] != 0) && (labeltable[datadst[posD]] < num))\par
1489                         num = labeltable[datadst[posD]];\par
1490 \par
1491                     {\cf20 // Atribui a etiqueta ao pixel}\par
1492                     datadst[posX] = num;\par
1493                     labeltable[num] = num;\par
1494 \par
1495                     {\cf20 // Actualiza a tabela de etiquetas}\par
1496                     {\cf19 if} (datadst[posA] != 0)\par
1497                     \{\par
1498                         {\cf19 if} (labeltable[datadst[posA]] != num)\par
1499                         \{\par
1500                             {\cf19 for} (tmplabel = labeltable[datadst[posA]], a = 1; a < label; a++)\par
1501                             \{\par
1502                                 {\cf19 if} (labeltable[a] == tmplabel)\par
1503                                 \{\par
1504                                     labeltable[a] = num;\par
1505                                 \}\par
1506                             \}\par
1507                         \}\par
1508                     \}\par
1509                     {\cf19 if} (datadst[posB] != 0)\par
1510                     \{\par
1511                         {\cf19 if} (labeltable[datadst[posB]] != num)\par
1512                         \{\par
1513                             {\cf19 for} (tmplabel = labeltable[datadst[posB]], a = 1; a < label; a++)\par
1514                             \{\par
1515                                 {\cf19 if} (labeltable[a] == tmplabel)\par
1516                                 \{\par
1517                                     labeltable[a] = num;\par
1518                                 \}\par
1519                             \}\par
1520                         \}\par
1521                     \}\par
1522                     {\cf19 if} (datadst[posC] != 0)\par
1523                     \{\par
1524                         {\cf19 if} (labeltable[datadst[posC]] != num)\par
1525                         \{\par
1526                             {\cf19 for} (tmplabel = labeltable[datadst[posC]], a = 1; a < label; a++)\par
1527                             \{\par
1528                                 {\cf19 if} (labeltable[a] == tmplabel)\par
1529                                 \{\par
1530                                     labeltable[a] = num;\par
1531                                 \}\par
1532                             \}\par
1533                         \}\par
1534                     \}\par
1535                     {\cf19 if} (datadst[posD] != 0)\par
1536                     \{\par
1537                         {\cf19 if} (labeltable[datadst[posD]] != num)\par
1538                         \{\par
1539                             {\cf19 for} (tmplabel = labeltable[datadst[posD]], a = 1; a < label; a++)\par
1540                             \{\par
1541                                 {\cf19 if} (labeltable[a] == tmplabel)\par
1542                                 \{\par
1543                                     labeltable[a] = num;\par
1544                                 \}\par
1545                             \}\par
1546                         \}\par
1547                     \}\par
1548                 \}\par
1549             \}\par
1550         \}\par
1551     \}\par
1552 \par
1553     {\cf20 // Volta a etiquetar a imagem}\par
1554     {\cf19 for} (y = 1; y < height - 1; y++)\par
1555     \{\par
1556         {\cf19 for} (x = 1; x < width - 1; x++)\par
1557         \{\par
1558             posX = y * bytesperline + x * channels; {\cf20 // X}\par
1559 \par
1560             {\cf19 if} (datadst[posX] != 0)\par
1561             \{\par
1562                 datadst[posX] = labeltable[datadst[posX]];\par
1563             \}\par
1564         \}\par
1565     \}\par
1566 \par
1567     {\cf20 // printf("\\nMax Label = %d\\n", label);}\par
1568 \par
1569     {\cf20 // Contagem do n\'EF\'BF\'BDmero de blobs}\par
1570     {\cf20 // Passo 1: Eliminar, da tabela, etiquetas repetidas}\par
1571     {\cf19 for} (a = 1; a < label - 1; a++)\par
1572     \{\par
1573         {\cf19 for} (b = a + 1; b < label; b++)\par
1574         \{\par
1575             {\cf19 if} (labeltable[a] == labeltable[b])\par
1576                 labeltable[b] = 0;\par
1577         \}\par
1578     \}\par
1579     {\cf20 // Passo 2: Conta etiquetas e organiza a tabela de etiquetas, para que n\'EF\'BF\'BDo hajam valores vazios (zero) entre etiquetas}\par
1580     *nlabels = 0;\par
1581     {\cf19 for} (a = 1; a < label; a++)\par
1582     \{\par
1583         {\cf19 if} (labeltable[a] != 0)\par
1584         \{\par
1585             labeltable[*nlabels] = labeltable[a]; {\cf20 // Organiza tabela de etiquetas}\par
1586             (*nlabels)++;                         {\cf20 // Conta etiquetas}\par
1587         \}\par
1588     \}\par
1589 \par
1590     {\cf20 // Se n\'EF\'BF\'BDo h\'EF\'BF\'BD blobs}\par
1591     {\cf19 if} (*nlabels == 0)\par
1592         {\cf19 return} NULL;\par
1593 \par
1594     {\cf20 // Cria lista de blobs (objectos) e preenche a etiqueta}\par
1595     blobs = (OVC *)calloc((*nlabels), {\cf17 sizeof}(OVC));\par
1596     {\cf19 if} (blobs != NULL)\par
1597     \{\par
1598         {\cf19 for} (a = 0; a < (*nlabels); a++)\par
1599             blobs[a].label = labeltable[a];\par
1600     \}\par
1601     {\cf19 else}\par
1602         {\cf19 return} NULL;\par
1603 \par
1604     {\cf19 return} blobs;\par
1605 \}\par
}
}
{\xe \v vc_binary_close\:vc.c}
{\xe \v vc.c\:vc_binary_close}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_binary_close ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst}, int  {\i kernel})}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1200 \{\par
1201     {\cf18 int} ret = 1;\par
1202     IVC *tmp = vc_image_new(src->width, src->height, src->channels, src->levels);\par
1203 \par
1204     ret &= vc_binary_dilate(src, tmp, kernel);\par
1205     ret &= vc_binary_erode(tmp, dst, kernel);\par
1206 \par
1207     vc_image_free(tmp);\par
1208 \par
1209     {\cf19 return} ret;\par
1210 \}\par
}
}
{\xe \v vc_binary_dilate\:vc.c}
{\xe \v vc.c\:vc_binary_dilate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_binary_dilate ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst}, int  {\i kernel})}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1080 \{\par
1081     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
1082     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
1083     {\cf18 int} width = src->width;\par
1084     {\cf18 int} height = src->height;\par
1085     {\cf18 int} bytesperline = src->bytesperline;\par
1086     {\cf18 int} channels = src->channels;\par
1087     {\cf18 int} offset = (kernel - 1) / 2;\par
1088     {\cf18 int} x, y, kx, ky;\par
1089     {\cf18 int} soma;\par
1090     {\cf18 long} {\cf18 int} pos, posk;\par
1091     {\cf18 unsigned} {\cf18 char} threshold;\par
1092 \par
1093     {\cf20 // Check for valid conditions}\par
1094     {\cf19 if} ((src->width <= 0) || (src->height <= 0) || (src->data == NULL))\par
1095         {\cf19 return} 0;\par
1096     {\cf19 if} ((src->width != dst->width) || (src->height != dst->height) || (src->channels != dst->channels))\par
1097         {\cf19 return} 0;\par
1098     {\cf19 if} (channels != 1)\par
1099         {\cf19 return} 0;\par
1100 \par
1101     {\cf19 for} (y = 0; y < height; y++)\par
1102     \{\par
1103         {\cf19 for} (x = 0; x < width; x++)\par
1104         \{\par
1105             pos = y * bytesperline + x * channels;\par
1106 \par
1107             soma = 0;\par
1108             {\cf19 for} (ky = -offset; ky <= offset; ky++)\par
1109             \{\par
1110 \par
1111                 {\cf19 for} (kx = -offset; kx <= offset; kx++)\par
1112                 \{\par
1113                     {\cf19 if} ((y + ky >= 0) && (y + ky < height) && (x + kx >= 0) && (x + kx < width))\par
1114                     \{\par
1115                         posk = (y + ky) * bytesperline + (x + kx) * channels;\par
1116 \par
1117                         soma += datasrc[posk];\par
1118                     \}\par
1119                 \}\par
1120             \}\par
1121 \par
1122             {\cf19 if} (soma >= 1)\par
1123                 datadst[pos] = 255;\par
1124             {\cf19 else}\par
1125                 datadst[pos] = 0;\par
1126         \}\par
1127     \}\par
1128     {\cf19 return} 1;\par
1129 \}\par
}
}
{\xe \v vc_binary_erode\:vc.c}
{\xe \v vc.c\:vc_binary_erode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_binary_erode ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst}, int  {\i kernel})}}
\par
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1132 \{\par
1133     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
1134     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
1135     {\cf18 int} width = src->width;\par
1136     {\cf18 int} height = src->height;\par
1137     {\cf18 int} bytesperline = src->bytesperline;\par
1138     {\cf18 int} channels = src->channels;\par
1139     {\cf18 int} offset = (kernel - 1) / 2;\par
1140     {\cf18 int} x, y, kx, ky;\par
1141     {\cf18 int} ww;\par
1142     {\cf18 long} {\cf18 int} pos, posk;\par
1143     {\cf18 unsigned} {\cf18 char} threshold;\par
1144 \par
1145     {\cf20 // Check for valid conditions}\par
1146     {\cf19 if} ((src->width <= 0) || (src->height <= 0) || (src->data == NULL))\par
1147         {\cf19 return} 0;\par
1148     {\cf19 if} ((src->width != dst->width) || (src->height != dst->height) || (src->channels != dst->channels))\par
1149         {\cf19 return} 0;\par
1150     {\cf19 if} (channels != 1)\par
1151         {\cf19 return} 0;\par
1152 \par
1153     {\cf19 for} (y = 0; y < height; y++)\par
1154     \{\par
1155         {\cf19 for} (x = 0; x < width; x++)\par
1156         \{\par
1157             pos = y * bytesperline + x * channels;\par
1158 \par
1159             ww = 0;\par
1160             {\cf19 for} (ky = -offset; ky <= offset; ky++)\par
1161             \{\par
1162 \par
1163                 {\cf19 for} (kx = -offset; kx <= offset; kx++)\par
1164                 \{\par
1165                     {\cf19 if} ((y + ky >= 0) && (y + ky < height) && (x + kx >= 0) && (x + kx < width))\par
1166                     \{\par
1167                         posk = (y + ky) * bytesperline + (x + kx) * channels;\par
1168 \par
1169                         {\cf19 if} (datasrc[posk] == 0)\par
1170                         \{\par
1171                             ww = 1;\par
1172                         \}\par
1173                     \}\par
1174                 \}\par
1175             \}\par
1176 \par
1177             {\cf19 if} (ww == 1)\par
1178                 datadst[pos] = 0;\par
1179             {\cf19 else}\par
1180                 datadst[pos] = 255;\par
1181         \}\par
1182     \}\par
1183     {\cf19 return} 1;\par
1184 \}\par
}
}
{\xe \v vc_binary_open\:vc.c}
{\xe \v vc.c\:vc_binary_open}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_binary_open ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst}, int  {\i kernel})}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1187 \{\par
1188     {\cf18 int} ret = 1;\par
1189     IVC *tmp = vc_image_new(src->width, src->height, src->channels, src->levels);\par
1190 \par
1191     ret &= vc_binary_erode(src, tmp, kernel);\par
1192     ret &= vc_binary_dilate(tmp, dst, kernel);\par
1193 \par
1194     vc_image_free(tmp);\par
1195 \par
1196     {\cf19 return} ret;\par
1197 \}\par
}
}
{\xe \v vc_coloring\:vc.c}
{\xe \v vc.c\:vc_coloring}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_coloring ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst}, int  {\i nlabels})}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1690 \{\par
1691     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
1692     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
1693     {\cf18 int} width = src->width;\par
1694     {\cf18 int} height = src->height;\par
1695     {\cf18 int} bytesperline_src = src->bytesperline;\par
1696     {\cf18 int} bytesperline_dst = dst->bytesperline;\par
1697     {\cf18 int} channels_src = src->channels;\par
1698     {\cf18 int} channels_dst = dst->channels;\par
1699     {\cf18 int} x, y;\par
1700 \par
1701     {\cf20 // Define gray range and compute increment}\par
1702     {\cf18 int} min_gray = 50;\par
1703     {\cf18 int} max_gray = 255;\par
1704     {\cf18 float} gray_increment = (nlabels > 1) ? (max_gray - min_gray) / (float)(nlabels - 1) : 0;\par
1705 \par
1706     {\cf19 for} (y = 0; y < height; y++)\par
1707     \{\par
1708         {\cf19 for} (x = 0; x < width; x++)\par
1709         \{\par
1710             {\cf18 long} {\cf18 int} pos = y * bytesperline_src + x * channels_src;\par
1711             {\cf18 unsigned} {\cf18 char} label = datasrc[pos];\par
1712 \par
1713             {\cf19 if} (label == 0)\par
1714             \{\par
1715                 datadst[pos] = 0; {\cf20 // Background remains black}\par
1716             \}\par
1717             {\cf19 else} {\cf19 if} (label > 0 && label <= nlabels)\par
1718             \{\par
1719                 {\cf18 float} gray_shade = min_gray + (label - 1) * gray_increment;\par
1720                 datadst[pos] = ({\cf18 unsigned} char)(gray_shade + 0.5f); {\cf20 // Rounding to nearest integer}\par
1721             \}\par
1722         \}\par
1723     \}\par
1724 \par
1725     {\cf19 return} 1;\par
1726 \}\par
}
}
{\xe \v vc_draw_boundingbox\:vc.c}
{\xe \v vc.c\:vc_draw_boundingbox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_draw_boundingbox ({\b IVC} *  {\i srcdst}, {\b OVC} *  {\i blobs}, int  {\i nblobs})}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1729 \{\par
1730     {\cf18 unsigned} {\cf18 char} *data = srcdst->data;\par
1731     {\cf18 int} width = srcdst->width;\par
1732     {\cf18 int} height = srcdst->height;\par
1733     {\cf18 int} bytesperline = srcdst->bytesperline;\par
1734     {\cf18 int} channels = srcdst->channels;\par
1735     {\cf18 int} x, y, i;\par
1736 \par
1737     {\cf20 // Verify the validity of input parameters}\par
1738     {\cf19 if} (!data || width <= 0 || height <= 0 || channels < 1)\par
1739         {\cf19 return} 0;\par
1740 \par
1741     {\cf20 // Process each blob}\par
1742     {\cf19 for} (i = 0; i < nblobs; i++)\par
1743     \{\par
1744         {\cf18 int} xmin = blobs[i].x;\par
1745         {\cf18 int} ymin = blobs[i].y;\par
1746         {\cf18 int} xmax = xmin + blobs[i].width;\par
1747         {\cf18 int} ymax = ymin + blobs[i].height;\par
1748 \par
1749         {\cf20 // Ensure the bounding box is within the image boundaries}\par
1750         xmin = MY_MAX(0, xmin);\par
1751         ymin = MY_MAX(0, ymin);\par
1752         xmax = MY_MIN(width - 1, xmax);\par
1753         ymax = MY_MIN(height - 1, ymax);\par
1754 \par
1755         {\cf20 // Draw horizontal lines at the top and bottom of the bounding box}\par
1756         {\cf19 for} (x = xmin; x <= xmax; x++)\par
1757         \{\par
1758             {\cf18 int} topPos = ymin * bytesperline + x * channels;\par
1759             {\cf18 int} bottomPos = ymax * bytesperline + x * channels;\par
1760             {\cf19 for} ({\cf18 int} channel = 0; channel < channels; channel++)\par
1761             \{\par
1762                 data[topPos + channel] = 255;    {\cf20 // Set to white}\par
1763                 data[bottomPos + channel] = 255; {\cf20 // Set to white}\par
1764             \}\par
1765         \}\par
1766 \par
1767         {\cf20 // Draw vertical lines on the left and right of the bounding box}\par
1768         {\cf19 for} (y = ymin; y <= ymax; y++)\par
1769         \{\par
1770             {\cf18 int} leftPos = y * bytesperline + xmin * channels;\par
1771             {\cf18 int} rightPos = y * bytesperline + xmax * channels;\par
1772             {\cf19 for} ({\cf18 int} channel = 0; channel < channels; channel++)\par
1773             \{\par
1774                 data[leftPos + channel] = 255;  {\cf20 // Set to white}\par
1775                 data[rightPos + channel] = 255; {\cf20 // Set to white}\par
1776             \}\par
1777         \}\par
1778     \}\par
1779 \par
1780     {\cf19 return} 1;\par
1781 \}\par
}
}
{\xe \v vc_draw_centerofgravity\:vc.c}
{\xe \v vc.c\:vc_draw_centerofgravity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_draw_centerofgravity ({\b IVC} *  {\i srcdst}, {\b OVC} *  {\i blobs}, int  {\i nblobs}, int  {\i s})}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1784 \{\par
1785     {\cf18 unsigned} {\cf18 char} *data = srcdst->data;\par
1786     {\cf18 int} width = srcdst->width;\par
1787     {\cf18 int} height = srcdst->height;\par
1788     {\cf18 int} bytesperline = srcdst->bytesperline;\par
1789     {\cf18 int} channels = srcdst->channels;\par
1790     {\cf18 int} c, x, y;\par
1791     {\cf18 int} xmin, xmax, ymin, ymax;\par
1792 \par
1793     {\cf20 // Check for valid data and image dimensions}\par
1794     {\cf19 if} (!data || width <= 0 || height <= 0 || channels < 1)\par
1795         {\cf19 return} 0;\par
1796 \par
1797     {\cf19 for} (c = 0; c < nblobs; c++)\par
1798     \{\par
1799         {\cf18 int} xc = blobs[c].xc;\par
1800         {\cf18 int} yc = blobs[c].yc;\par
1801 \par
1802         ymin = yc - s;\par
1803         ymax = yc + s;\par
1804         xmin = xc - s;\par
1805         xmax = xc + s;\par
1806 \par
1807         {\cf20 // Draw vertical line of the cross}\par
1808         {\cf19 for} (y = MY_MAX(0, ymin); y <= MY_MIN(ymax, height - 1); y++)\par
1809         \{\par
1810             {\cf18 int} pos = y * bytesperline + xc * channels;\par
1811             {\cf19 if} (xc >= 0 && xc < width)\par
1812             \{\par
1813                 {\cf19 for} ({\cf18 int} channel = 0; channel < channels; channel++)\par
1814                 \{\par
1815                     data[pos + channel] = 255; {\cf20 // Set to white}\par
1816                 \}\par
1817             \}\par
1818         \}\par
1819 \par
1820         {\cf20 // Draw horizontal line of the cross}\par
1821         {\cf19 for} (x = MY_MAX(0, xmin); x <= MY_MIN(xmax, width - 1); x++)\par
1822         \{\par
1823             {\cf18 int} pos = yc * bytesperline + x * channels;\par
1824             {\cf19 if} (yc >= 0 && yc < height)\par
1825             \{\par
1826                 {\cf19 for} ({\cf18 int} channel = 0; channel < channels; channel++)\par
1827                 \{\par
1828                     data[pos + channel] = 255; {\cf20 // Set to white}\par
1829                 \}\par
1830             \}\par
1831         \}\par
1832     \}\par
1833 \par
1834     {\cf19 return} 1;\par
1835 \}\par
}
}
{\xe \v vc_gray_close\:vc.c}
{\xe \v vc.c\:vc_gray_close}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_gray_close ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst}, int  {\i kernel})}}
\par
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1331 \{\par
1332     {\cf18 int} ret = 1;\par
1333     IVC *tmp = vc_image_new(src->width, src->height, src->channels, src->levels);\par
1334 \par
1335     ret &= vc_gray_dilate(src, tmp, kernel);\par
1336     ret &= vc_gray_erode(tmp, dst, kernel);\par
1337 \par
1338     vc_image_free(tmp);\par
1339 \par
1340     {\cf19 return} ret;\par
1341 \}\par
}
}
{\xe \v vc_gray_dilate\:vc.c}
{\xe \v vc.c\:vc_gray_dilate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_gray_dilate ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst}, int  {\i kernel})}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1213 \{\par
1214     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
1215     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
1216     {\cf18 int} width = src->width;\par
1217     {\cf18 int} height = src->height;\par
1218     {\cf18 int} bytesperline = src->bytesperline;\par
1219     {\cf18 int} channels = src->channels;\par
1220     {\cf18 int} offset = (kernel - 1) / 2;\par
1221     {\cf18 int} x, y, kx, ky;\par
1222     {\cf18 int} soma, max, w;\par
1223     {\cf18 long} {\cf18 int} pos, posk;\par
1224     {\cf18 unsigned} {\cf18 char} threshold;\par
1225 \par
1226     {\cf20 // Check for valid conditions}\par
1227     {\cf19 if} ((src->width <= 0) || (src->height <= 0) || (src->data == NULL))\par
1228         {\cf19 return} 0;\par
1229     {\cf19 if} ((src->width != dst->width) || (src->height != dst->height) || (src->channels != dst->channels))\par
1230         {\cf19 return} 0;\par
1231     {\cf19 if} (channels != 1)\par
1232         {\cf19 return} 0;\par
1233 \par
1234     {\cf19 for} (y = 0; y < height; y++)\par
1235     \{\par
1236         {\cf19 for} (x = 0; x < width; x++)\par
1237         \{\par
1238             pos = y * bytesperline + x * channels;\par
1239 \par
1240             max = 0;\par
1241 \par
1242             {\cf19 for} (ky = -offset; ky <= offset; ky++)\par
1243             \{\par
1244 \par
1245                 {\cf19 for} (kx = -offset; kx <= offset; kx++)\par
1246                 \{\par
1247                     {\cf19 if} ((y + ky >= 0) && (y + ky < height) && (x + kx >= 0) && (x + kx < width))\par
1248                     \{\par
1249                         posk = (y + ky) * bytesperline + (x + kx) * channels;\par
1250 \par
1251                         {\cf19 if} (max < datasrc[posk])\par
1252                         \{\par
1253                             max = datasrc[posk];\par
1254                         \}\par
1255                     \}\par
1256                 \}\par
1257             \}\par
1258 \par
1259             datadst[pos] = max;\par
1260         \}\par
1261     \}\par
1262     {\cf19 return} 1;\par
1263 \}\par
}
}
{\xe \v vc_gray_edge_prewitt\:vc.c}
{\xe \v vc.c\:vc_gray_edge_prewitt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_gray_edge_prewitt ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst}, float  {\i th})}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1952 \{\par
1953     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
1954     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
1955     {\cf18 int} width = src->width;\par
1956     {\cf18 int} height = src->height;\par
1957     {\cf18 int} bytesperline = src->bytesperline;\par
1958     {\cf18 int} channels = src->channels;\par
1959     {\cf18 int} x, y;\par
1960     {\cf18 long} {\cf18 int} posX, posA, posB, posC, posD, posE, posF, posG, posH;\par
1961     {\cf18 int} i, size;\par
1962     {\cf18 float} histmax;\par
1963     {\cf18 int} histthreshold;\par
1964     {\cf18 int} sumx, sumy;\par
1965     {\cf18 float} hist[256] = \{0.0f\};\par
1966 \par
1967     {\cf20 // Verifica\'E7\'E3o de erros}\par
1968     {\cf19 if} ((src->width <= 0) || (src->height <= 0) || (src->data == NULL))\par
1969         {\cf19 return} 0;\par
1970     {\cf19 if} ((src->width != dst->width) || (src->height != dst->height) || (src->channels != dst->channels))\par
1971         {\cf19 return} 0;\par
1972     {\cf19 if} (channels != 1)\par
1973         {\cf19 return} 0;\par
1974 \par
1975     size = width * height;\par
1976 \par
1977     {\cf19 for} (y = 1; y < height - 1; y++)\par
1978     \{\par
1979         {\cf19 for} (x = 1; x < width - 1; x++)\par
1980         \{\par
1981             {\cf20 // PosA PosB PosC}\par
1982             {\cf20 // PosD PosX PosE}\par
1983             {\cf20 // PosF PosG PosH}\par
1984 \par
1985             posA = (y - 1) * bytesperline + (x - 1) * channels;\par
1986             posB = (y - 1) * bytesperline + x * channels;\par
1987             posC = (y - 1) * bytesperline + (x + 1) * channels;\par
1988             posD = y * bytesperline + (x - 1) * channels;\par
1989             posX = y * bytesperline + x * channels;\par
1990             posE = y * bytesperline + (x + 1) * channels;\par
1991             posF = (y + 1) * bytesperline + (x - 1) * channels;\par
1992             posG = (y + 1) * bytesperline + x * channels;\par
1993             posH = (y + 1) * bytesperline + (x + 1) * channels;\par
1994 \par
1995             {\cf20 // PosA*(-1) PosB*0 PosC*(1)}\par
1996             {\cf20 // PosD*(-1) PosX*0 PosE*(1)}\par
1997             {\cf20 // PosF*(-1) PosG*0 PosH*(1)}\par
1998 \par
1999             sumx = datasrc[posA] * -1;\par
2000             sumx += datasrc[posD] * -1;\par
2001             sumx += datasrc[posF] * -1;\par
2002 \par
2003             sumx += datasrc[posC] * +1;\par
2004             sumx += datasrc[posE] * +1;\par
2005             sumx += datasrc[posH] * +1;\par
2006             sumx = sumx / 3; {\cf20 // 3 = 1 + 1 + 1}\par
2007 \par
2008             {\cf20 // PosA*(-1) PosB*(-1) PosC*(-1)}\par
2009             {\cf20 // PosD*0    PosX*0    PosE*0}\par
2010             {\cf20 // PosF*(1)  PosG*(1)  PosH*(1)}\par
2011 \par
2012             sumy = datasrc[posA] * -1;\par
2013             sumy += datasrc[posB] * -1;\par
2014             sumy += datasrc[posC] * -1;\par
2015 \par
2016             sumy += datasrc[posF] * +1;\par
2017             sumy += datasrc[posG] * +1;\par
2018             sumy += datasrc[posH] * +1;\par
2019             sumy = sumy / 3; {\cf20 // 3 = 1 + 1 + 1}\par
2020 \par
2021             {\cf20 // datadst[posX] = (unsigned char)sqrt((double)(sumx*sumx + sumy*sumy));}\par
2022             datadst[posX] = ({\cf18 unsigned} char)(sqrt(({\cf18 double})(sumx * sumx + sumy * sumy)) / sqrt(2.0));\par
2023             {\cf20 // Explica\'E7\'E3o:}\par
2024             {\cf20 // Queremos que no caso do pior cen\'E1rio, em que sumx = sumy = 255, o resultado}\par
2025             {\cf20 // da opera\'E7\'E3o se mantenha no intervalo de valores admitido, isto \'E9, entre [0, 255].}\par
2026             {\cf20 // Se se considerar que:}\par
2027             {\cf20 // max = 255}\par
2028             {\cf20 // Ent\'E3o,}\par
2029             {\cf20 // sqrt(pow(max,2) + pow(max,2)) * k = max <=> sqrt(2*pow(max,2)) * k = max <=> k = max / (sqrt(2) * max) <=>}\par
2030             {\cf20 // k = 1 / sqrt(2)}\par
2031         \}\par
2032     \}\par
2033 \par
2034     {\cf20 // Calcular o histograma com o valor das magnitudes}\par
2035     {\cf19 for} (i = 0; i < size; i++)\par
2036     \{\par
2037         hist[datadst[i]]++;\par
2038     \}\par
2039 \par
2040     {\cf20 // Definir o threshold.}\par
2041     {\cf20 // O threshold \'E9 definido pelo n\'EDvel de intensidade (das magnitudes)}\par
2042     {\cf20 // quando se atinge uma determinada percentagem de pixeis, definida pelo utilizador.}\par
2043     {\cf20 // Por exemplo, se o par\'E2metro 'th' tiver valor 0.8, significa the o threshold ser\'E1 o}\par
2044     {\cf20 // n\'EDvel de magnitude, abaixo do qual est\'E3o pelo menos 80% dos pixeis.}\par
2045     histmax = 0.0f;\par
2046     {\cf19 for} (i = 0; i <= 255; i++)\par
2047     \{\par
2048         histmax += hist[i];\par
2049 \par
2050         {\cf20 // th = Prewitt Threshold}\par
2051         {\cf19 if} (histmax >= ((({\cf18 float})size) * th))\par
2052             {\cf19 break};\par
2053     \}\par
2054     histthreshold = i == 0 ? 1 : i;\par
2055 \par
2056     {\cf20 // Aplicada o threshold}\par
2057     {\cf19 for} (i = 0; i < size; i++)\par
2058     \{\par
2059         {\cf19 if} (datadst[i] >= ({\cf18 unsigned} {\cf18 char})histthreshold)\par
2060             datadst[i] = 255;\par
2061         {\cf19 else}\par
2062             datadst[i] = 0;\par
2063     \}\par
2064 \par
2065     {\cf19 return} 1;\par
2066 \}\par
}
}
{\xe \v vc_gray_erode\:vc.c}
{\xe \v vc.c\:vc_gray_erode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_gray_erode ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst}, int  {\i kernel})}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1266 \{\par
1267     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
1268     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
1269     {\cf18 int} width = src->width;\par
1270     {\cf18 int} height = src->height;\par
1271     {\cf18 int} bytesperline = src->bytesperline;\par
1272     {\cf18 int} channels = src->channels;\par
1273     {\cf18 int} offset = (kernel - 1) / 2;\par
1274     {\cf18 int} x, y, kx, ky;\par
1275     {\cf18 int} min;\par
1276     {\cf18 long} {\cf18 int} pos, posk;\par
1277     {\cf18 unsigned} {\cf18 char} threshold;\par
1278 \par
1279     {\cf20 // Check for valid conditions}\par
1280     {\cf19 if} ((src->width <= 0) || (src->height <= 0) || (src->data == NULL))\par
1281         {\cf19 return} 0;\par
1282     {\cf19 if} ((src->width != dst->width) || (src->height != dst->height) || (src->channels != dst->channels))\par
1283         {\cf19 return} 0;\par
1284     {\cf19 if} (channels != 1)\par
1285         {\cf19 return} 0;\par
1286 \par
1287     {\cf19 for} (y = 0; y < height; y++)\par
1288     \{\par
1289         {\cf19 for} (x = 0; x < width; x++)\par
1290         \{\par
1291             pos = y * bytesperline + x * channels;\par
1292 \par
1293             min = 255;\par
1294             {\cf19 for} (ky = -offset; ky <= offset; ky++)\par
1295             \{\par
1296 \par
1297                 {\cf19 for} (kx = -offset; kx <= offset; kx++)\par
1298                 \{\par
1299                     {\cf19 if} ((y + ky >= 0) && (y + ky < height) && (x + kx >= 0) && (x + kx < width))\par
1300                     \{\par
1301                         posk = (y + ky) * bytesperline + (x + kx) * channels;\par
1302 \par
1303                         {\cf19 if} (min > datasrc[posk])\par
1304                         \{\par
1305                             min = datasrc[posk];\par
1306                         \}\par
1307                     \}\par
1308                 \}\par
1309             \}\par
1310 \par
1311             datadst[pos] = min;\par
1312         \}\par
1313     \}\par
1314     {\cf19 return} 1;\par
1315 \}\par
}
}
{\xe \v vc_gray_histogram_equalization\:vc.c}
{\xe \v vc.c\:vc_gray_histogram_equalization}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_gray_histogram_equalization ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst})}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1906 \{\par
1907     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
1908     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
1909     {\cf18 int} width = src->width;\par
1910     {\cf18 int} height = src->height;\par
1911     {\cf18 int} bytesperline_src = src->width * src->channels;\par
1912     {\cf18 int} bytesperline_dst = dst->width * dst->channels;\par
1913     {\cf18 int} total_pixels = width * height;\par
1914     {\cf18 int} histogram[256] = \{0\};\par
1915     {\cf18 int} cumulative_histogram[256] = \{0\};\par
1916 \par
1917     {\cf19 for} ({\cf18 int} y = 0; y < height; y++)\par
1918     \{\par
1919         {\cf19 for} ({\cf18 int} x = 0; x < width; x++)\par
1920         \{\par
1921             {\cf18 int} pos_src = y * bytesperline_src + x;\par
1922             histogram[datasrc[pos_src]]++;\par
1923         \}\par
1924     \}\par
1925 \par
1926     cumulative_histogram[0] = histogram[0];\par
1927     {\cf19 for} ({\cf18 int} i = 1; i < 256; i++)\par
1928     \{\par
1929         cumulative_histogram[i] = cumulative_histogram[i - 1] + histogram[i];\par
1930     \}\par
1931 \par
1932     {\cf18 float} equalization_function[256];\par
1933     {\cf19 for} ({\cf18 int} i = 0; i < 256; i++)\par
1934     \{\par
1935         equalization_function[i] = ((float)cumulative_histogram[i] / total_pixels) * 255;\par
1936     \}\par
1937 \par
1938     {\cf19 for} ({\cf18 int} y = 0; y < height; y++)\par
1939     \{\par
1940         {\cf19 for} ({\cf18 int} x = 0; x < width; x++)\par
1941         \{\par
1942             {\cf18 int} pos_src = y * bytesperline_src + x;\par
1943             {\cf18 int} pos_dst = y * bytesperline_dst + x;\par
1944             datadst[pos_dst] = equalization_function[datasrc[pos_src]];\par
1945         \}\par
1946     \}\par
1947 \par
1948     {\cf19 return} 1;\par
1949 \}\par
}
}
{\xe \v vc_gray_histogram_show\:vc.c}
{\xe \v vc.c\:vc_gray_histogram_show}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_gray_histogram_show ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst})}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1838 \{\par
1839     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
1840     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
1841     {\cf18 int} width = src->width;\par
1842     {\cf18 int} height = src->height;\par
1843     {\cf18 int} bytesperline_src = src->bytesperline;\par
1844     {\cf18 int} bytesperline_dst = dst->bytesperline;\par
1845     {\cf18 int} channels_dst = dst->channels;\par
1846     {\cf18 int} x, y;\par
1847     {\cf18 int} hist[256] = \{0\}; {\cf20 // Initialize histogram array to zero}\par
1848     {\cf18 int} max_count = 0;\par
1849     {\cf18 int} normalized_height[256];\par
1850 \par
1851     {\cf20 // Compute histogram}\par
1852     {\cf19 for} (y = 0; y < height; y++)\par
1853     \{\par
1854         {\cf19 for} (x = 0; x < width; x++)\par
1855         \{\par
1856             {\cf18 int} pixel_value = datasrc[y * bytesperline_src + x]; {\cf20 // Access pixel value}\par
1857             hist[pixel_value]++;\par
1858         \}\par
1859     \}\par
1860 \par
1861     {\cf20 // Find maximum count in histogram for normalization}\par
1862     {\cf19 for} ({\cf18 int} i = 0; i < 256; i++)\par
1863     \{\par
1864         {\cf19 if} (hist[i] > max_count)\par
1865         \{\par
1866             max_count = hist[i];\par
1867         \}\par
1868     \}\par
1869 \par
1870     {\cf20 // Normalize histogram heights}\par
1871     {\cf19 for} ({\cf18 int} i = 0; i < 256; i++)\par
1872     \{\par
1873         normalized_height[i] = (hist[i] * height) / max_count; {\cf20 // Scale to image height}\par
1874     \}\par
1875 \par
1876     {\cf19 for} ({\cf18 int} i = 0; i < 256; i++)\par
1877     \{\par
1878         printf({\cf22 "Intensity %d: %d pixels |||  %d \\n"}, i, normalized_height[i], hist[i]);\par
1879     \}\par
1880 \par
1881     printf({\cf22 "Maximco: %d \\n"}, max_count);\par
1882 \par
1883     {\cf19 for} (y = 0; y < height; y++)\par
1884     \{\par
1885         {\cf19 for} (x = 0; x < 256; x++)\par
1886         \{\par
1887 \par
1888             datadst[y * bytesperline_dst + x * channels_dst] = 0;\par
1889         \}\par
1890     \}\par
1891 \par
1892     {\cf20 // Draw histogram in destination image}\par
1893     {\cf19 for} ({\cf18 int} i = 0; i < 256 && i < width; i++)\par
1894     \{\par
1895         {\cf19 for} (y = height - 1; y >= height - normalized_height[i] && y >= 0; y--)\par
1896         \{\par
1897             {\cf18 long} {\cf18 int} posdst = y * bytesperline_dst + i * channels_dst;\par
1898             datadst[posdst] = 255;\par
1899         \}\par
1900     \}\par
1901 \par
1902     {\cf19 return} 1;\par
1903 \}\par
}
}
{\xe \v vc_gray_negative\:vc.c}
{\xe \v vc.c\:vc_gray_negative}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_gray_negative ({\b IVC} *  {\i srcdst})}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 379 \{\par
380     {\cf18 unsigned} {\cf18 char} *data = ({\cf18 unsigned} {\cf18 char} *)srcdst->data;\par
381     {\cf18 int} width = srcdst->width;\par
382     {\cf18 int} height = srcdst->height;\par
383     {\cf18 int} bytesperline = srcdst->width * srcdst->channels;\par
384     {\cf18 int} channels = srcdst->channels;\par
385     {\cf18 int} x, y;\par
386     {\cf18 long} {\cf18 int} pos;\par
387 \par
388     if ((srcdst->width <= 0) || (srcdst->height <= 0) || (srcdst->data == NULL))\par
389         {\cf19 return} 0;\par
390     {\cf19 if} (channels != 1)\par
391         {\cf19 return} 0;\par
392 \par
393     {\cf19 for} (y = 0; y < height; y++)\par
394     \{\par
395         {\cf19 for} (x = 0; x < width; x++)\par
396         \{\par
397             pos = y * bytesperline + x * channels;\par
398 \par
399             data[pos] = 255 - data[pos];\par
400         \}\par
401     \}\par
402     {\cf19 return} 1;\par
403 \}\par
}
}
{\xe \v vc_gray_open\:vc.c}
{\xe \v vc.c\:vc_gray_open}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_gray_open ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst}, int  {\i kernel})}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1318 \{\par
1319     {\cf18 int} ret = 1;\par
1320     IVC *tmp = vc_image_new(src->width, src->height, src->channels, src->levels);\par
1321 \par
1322     ret &= vc_gray_erode(src, tmp, kernel);\par
1323     ret &= vc_gray_dilate(tmp, dst, kernel);\par
1324 \par
1325     vc_image_free(tmp);\par
1326 \par
1327     {\cf19 return} ret;\par
1328 \}\par
}
}
{\xe \v vc_gray_to_binary\:vc.c}
{\xe \v vc.c\:vc_gray_to_binary}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_gray_to_binary ({\b IVC} *  {\i srcdst}, int  {\i threshold})}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 808 \{\par
809     {\cf18 unsigned} {\cf18 char} *data = ({\cf18 unsigned} {\cf18 char} *)srcdst->data;\par
810     {\cf18 int} width = srcdst->width;\par
811     {\cf18 int} height = srcdst->height;\par
812     {\cf18 int} bytesperline = srcdst->width * srcdst->channels;\par
813     {\cf18 int} channels = srcdst->channels;\par
814     {\cf18 int} x, y, w;\par
815     {\cf18 long} {\cf18 int} pos;\par
816 \par
817     if ((srcdst->width <= 0) || (srcdst->height <= 0) || (srcdst->data == NULL))\par
818         {\cf19 return} 0;\par
819 \par
820     srcdst->levels = 1;\par
821 \par
822     {\cf19 for} (y = 0; y < height; y++)\par
823     \{\par
824         {\cf19 for} (x = 0; x < width; x++)\par
825         \{\par
826             pos = y * bytesperline + x * channels;\par
827 \par
828             {\cf19 if} (data[pos] <= ({\cf18 unsigned} {\cf18 char})threshold)\par
829                 data[pos] = 0;\par
830             {\cf19 else}\par
831                 data[pos] = 255;\par
832         \}\par
833     \}\par
834     {\cf19 return} 1;\par
835 \}\par
}
}
{\xe \v vc_gray_to_binary_bernsen\:vc.c}
{\xe \v vc.c\:vc_gray_to_binary_bernsen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_gray_to_binary_bernsen ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst}, int  {\i kernel}, int  {\i cmin})}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 938 \{\par
939     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
940     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
941     {\cf18 int} width = src->width;\par
942     {\cf18 int} height = src->height;\par
943     {\cf18 int} bytesperline = src->bytesperline;\par
944     {\cf18 int} channels = src->channels;\par
945     {\cf18 int} offset = (kernel - 1) / 2;\par
946     {\cf18 int} x, y, kx, ky;\par
947     {\cf18 int} min, max;\par
948     {\cf18 long} {\cf18 int} pos, posk;\par
949     {\cf18 unsigned} {\cf18 char} threshold;\par
950     {\cf18 int} levels = src->levels;\par
951 \par
952     {\cf20 // Check for valid conditions}\par
953     {\cf19 if} ((src->width <= 0) || (src->height <= 0) || (src->data == NULL))\par
954         {\cf19 return} 0;\par
955     {\cf19 if} ((src->width != dst->width) || (src->height != dst->height) || (src->channels != dst->channels))\par
956         {\cf19 return} 0;\par
957     {\cf19 if} (channels != 1)\par
958         {\cf19 return} 0;\par
959 \par
960     {\cf19 for} (y = 0; y < height; y++)\par
961     \{\par
962         {\cf19 for} (x = 0; x < width; x++)\par
963         \{\par
964             pos = y * bytesperline + x * channels;\par
965 \par
966             max = 0;\par
967             min = 255;\par
968 \par
969             {\cf19 for} (ky = -offset; ky <= offset; ky++)\par
970             \{\par
971                 {\cf19 for} (kx = -offset; kx <= offset; kx++)\par
972                 \{\par
973                     {\cf19 if} ((y + ky >= 0) && (y + ky < height) && (x + kx >= 0) && (x + kx < width))\par
974                     \{\par
975                         posk = (y + ky) * bytesperline + (x + kx) * channels;\par
976 \par
977                         {\cf19 if} (datasrc[posk] > max)\par
978                             max = datasrc[posk];\par
979                         {\cf19 if} (datasrc[posk] < min)\par
980                             min = datasrc[posk];\par
981                     \}\par
982                 \}\par
983             \}\par
984 \par
985             {\cf19 if} ((({\cf18 float})(max - min)) < cmin)\par
986             \{\par
987                 threshold = ({\cf18 unsigned} char)(({\cf18 float})levels / (float)2);\par
988             \}\par
989             {\cf19 else}\par
990             \{\par
991                 threshold = ({\cf18 unsigned} char)(({\cf18 float})(max + min) / ({\cf18 float})2);\par
992             \}\par
993             {\cf19 if} (datasrc[pos] > threshold)\par
994                 datadst[pos] = 255;\par
995             {\cf19 else}\par
996                 datadst[pos] = 0;\par
997         \}\par
998     \}\par
999     {\cf19 return} 1;\par
1000 \}\par
}
}
{\xe \v vc_gray_to_binary_global_mean\:vc.c}
{\xe \v vc.c\:vc_gray_to_binary_global_mean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_gray_to_binary_global_mean ({\b IVC} *  {\i srcdst})}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 838 \{\par
839     {\cf18 unsigned} {\cf18 char} *data = ({\cf18 unsigned} {\cf18 char} *)srcdst->data;\par
840     {\cf18 int} width = srcdst->width;\par
841     {\cf18 int} height = srcdst->height;\par
842     {\cf18 int} bytesperline = srcdst->width * srcdst->channels;\par
843     {\cf18 int} channels = srcdst->channels;\par
844     {\cf18 int} x, y, w;\par
845     {\cf18 long} {\cf18 int} pos, soma = 0;\par
846     {\cf18 int} threshold;\par
847 \par
848     if ((srcdst->width <= 0) || (srcdst->height <= 0) || (srcdst->data == NULL))\par
849         {\cf19 return} 0;\par
850 \par
851     {\cf19 for} (y = 0; y < height; y++)\par
852     \{\par
853 \par
854         {\cf19 for} (x = 0; x < width; x++)\par
855         \{\par
856             pos = y * bytesperline + x * channels;\par
857 \par
858             soma += data[pos];\par
859         \}\par
860     \}\par
861 \par
862     threshold = soma / (width * height);\par
863 \par
864     {\cf19 for} (y = 0; y < height; y++)\par
865     \{\par
866         {\cf19 for} (x = 0; x < width; x++)\par
867         \{\par
868             pos = y * bytesperline + x * channels;\par
869 \par
870             {\cf19 if} (data[pos] <= ({\cf18 unsigned} {\cf18 char})threshold)\par
871                 data[pos] = 0;\par
872             {\cf19 else}\par
873                 data[pos] = 255;\par
874         \}\par
875     \}\par
876 \par
877     {\cf19 return} 1;\par
878 \}\par
}
}
{\xe \v vc_gray_to_binary_midpoint\:vc.c}
{\xe \v vc.c\:vc_gray_to_binary_midpoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_gray_to_binary_midpoint ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst}, int  {\i kernel})}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 881 \{\par
882     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
883     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
884     {\cf18 int} width = src->width;\par
885     {\cf18 int} height = src->height;\par
886     {\cf18 int} bytesperline = src->bytesperline;\par
887     {\cf18 int} channels = src->channels;\par
888     {\cf18 int} offset = (kernel - 1) / 2;\par
889     {\cf18 int} x, y, kx, ky;\par
890     {\cf18 int} min, max;\par
891     {\cf18 long} {\cf18 int} pos, posk;\par
892     {\cf18 unsigned} {\cf18 char} threshold;\par
893 \par
894     {\cf20 // Check for valid conditions}\par
895     {\cf19 if} ((src->width <= 0) || (src->height <= 0) || (src->data == NULL))\par
896         {\cf19 return} 0;\par
897     {\cf19 if} ((src->width != dst->width) || (src->height != dst->height) || (src->channels != dst->channels))\par
898         {\cf19 return} 0;\par
899     {\cf19 if} (channels != 1)\par
900         {\cf19 return} 0;\par
901 \par
902     {\cf19 for} (y = 0; y < height; y++)\par
903     \{\par
904         {\cf19 for} (x = 0; x < width; x++)\par
905         \{\par
906             pos = y * bytesperline + x * channels;\par
907 \par
908             max = 0;\par
909             min = 255;\par
910 \par
911             {\cf19 for} (ky = -offset; ky <= offset; ky++)\par
912             \{\par
913                 {\cf19 for} (kx = -offset; kx <= offset; kx++)\par
914                 \{\par
915                     {\cf19 if} ((y + ky >= 0) && (y + ky < height) && (x + kx >= 0) && (x + kx < width))\par
916                     \{\par
917                         posk = (y + ky) * bytesperline + (x + kx) * channels;\par
918 \par
919                         {\cf19 if} (datasrc[posk] > max)\par
920                             max = datasrc[posk];\par
921                         {\cf19 if} (datasrc[posk] < min)\par
922                             min = datasrc[posk];\par
923                     \}\par
924                 \}\par
925             \}\par
926 \par
927             threshold = ({\cf18 unsigned} char)(({\cf18 float})(max + min) / ({\cf18 float})2);\par
928             {\cf19 if} (datasrc[pos] > threshold)\par
929                 datadst[pos] = 255;\par
930             {\cf19 else}\par
931                 datadst[pos] = 0;\par
932         \}\par
933     \}\par
934     {\cf19 return} 1;\par
935 \}\par
}
}
{\xe \v vc_gray_to_binary_niblack\:vc.c}
{\xe \v vc.c\:vc_gray_to_binary_niblack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_gray_to_binary_niblack ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst}, int  {\i kernel}, float  {\i k})}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1003 \{\par
1004     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
1005     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
1006     {\cf18 int} width = src->width;\par
1007     {\cf18 int} height = src->height;\par
1008     {\cf18 int} bytesperline = src->bytesperline;\par
1009     {\cf18 int} channels = src->channels;\par
1010     {\cf18 int} offset = (kernel - 1) / 2;\par
1011     {\cf18 int} x, y, xx, yy;\par
1012     {\cf18 int} min, max, counter;\par
1013     {\cf18 long} {\cf18 int} pos, posk;\par
1014     {\cf18 unsigned} {\cf18 char} threshold;\par
1015 \par
1016     {\cf20 // Check for valid conditions}\par
1017     {\cf19 if} ((src->width <= 0) || (src->height <= 0) || (src->data == NULL))\par
1018         {\cf19 return} 0;\par
1019     {\cf19 if} ((src->width != dst->width) || (src->height != dst->height) || (src->channels != dst->channels))\par
1020         {\cf19 return} 0;\par
1021     {\cf19 if} (channels != 1)\par
1022         {\cf19 return} 0;\par
1023 \par
1024     {\cf19 for} (y = 0; y < height; y++)\par
1025     \{\par
1026         {\cf19 for} (x = 0; x < width; x++)\par
1027         \{\par
1028             pos = y * bytesperline + x * channels;\par
1029 \par
1030             max = datasrc[pos];\par
1031             min = datasrc[pos];\par
1032 \par
1033             {\cf18 float} mean = 0.0f;\par
1034 \par
1035             {\cf19 for} (counter = 0, yy = -offset; yy <= offset; yy++)\par
1036             \{\par
1037                 {\cf19 for} (xx = -offset; xx <= offset; xx++)\par
1038                 \{\par
1039                     {\cf19 if} ((y + yy >= 0) && (y + yy < height) && (x + xx >= 0) && (x + xx < width))\par
1040                     \{\par
1041                         posk = (y + yy) * bytesperline + (x + xx) * channels;\par
1042 \par
1043                         mean += (float)datasrc[posk];\par
1044 \par
1045                         counter++;\par
1046                     \}\par
1047                 \}\par
1048             \}\par
1049 \par
1050             mean /= counter;\par
1051 \par
1052             {\cf18 float} sdeviatan = 0.0f;\par
1053 \par
1054             {\cf19 for} (counter = 0, yy = -offset; yy <= offset; yy++)\par
1055             \{\par
1056                 {\cf19 for} (xx = -offset; xx <= offset; xx++)\par
1057                 \{\par
1058                     {\cf19 if} ((y + yy >= 0) && (y + yy < height) && (x + xx >= 0) && (x + xx < width))\par
1059                     \{\par
1060                         posk = (y + yy) * bytesperline + (x + xx) * channels;\par
1061 \par
1062                         sdeviatan += powf((({\cf18 float})datasrc[posk]) - mean, 2);\par
1063                         counter++;\par
1064                     \}\par
1065                 \}\par
1066             \}\par
1067             sdeviatan = sqrtf(sdeviatan / counter);\par
1068             threshold = mean + k * sdeviatan;\par
1069 \par
1070             {\cf19 if} (datasrc[pos] > threshold)\par
1071                 datadst[pos] = 255;\par
1072             {\cf19 else}\par
1073                 datadst[pos] = 0;\par
1074         \}\par
1075     \}\par
1076     {\cf19 return} 1;\par
1077 \}\par
}
}
{\xe \v vc_hsv_segmentation\:vc.c}
{\xe \v vc.c\:vc_hsv_segmentation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_hsv_segmentation ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst}, int  {\i hmin}, int  {\i hmax}, int  {\i smin}, int  {\i smax}, int  {\i vmin}, int  {\i vmax})}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 642 \{\par
643     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
644     {\cf18 int} byterperline_src = src->width * src->channels;\par
645     {\cf18 int} channels_src = src->channels;\par
646     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
647     {\cf18 int} bytesperline_dst = dst->width * dst->channels;\par
648     {\cf18 int} channels_dst = dst->channels;\par
649     {\cf18 int} width = src->width;\par
650     {\cf18 int} height = src->height;\par
651     {\cf18 int} x, y;\par
652     {\cf18 long} {\cf18 int} pos_src, pos_dst;\par
653     {\cf18 float} h, s, v;\par
654 \par
655     {\cf19 if} (src->width <= 0 || src->height <= 0 || src->data == NULL)\par
656         {\cf19 return} 0;\par
657     {\cf19 if} (src->width != dst->width || src->height != dst->height)\par
658         {\cf19 return} 0;\par
659     {\cf19 if} (src->channels != 3 || dst->channels != 1)\par
660         {\cf19 return} 0;\par
661 \par
662     {\cf20 // Segmentation loop}\par
663     {\cf19 for} (y = 50; y < 158; y++)\par
664     \{\par
665         {\cf19 for} (x = 0; x < width; x++)\par
666         \{\par
667             pos_src = y * byterperline_src + x * channels_src;\par
668             pos_dst = y * bytesperline_dst + x * channels_dst;\par
669 \par
670             {\cf20 // Assuming HSV values are stored in src and are normalized [0, 255]}\par
671             h = (int)((({\cf18 float})datasrc[pos_src]) / 255.0f * 360.0f);\par
672             s = (int)((({\cf18 float})datasrc[pos_src + 1]) / 255.0f * 100.0f);\par
673             v = (int)((({\cf18 float})datasrc[pos_src + 2]) / 255.0f * 100.0f);\par
674 \par
675             {\cf20 // Check if the pixel falls within the specified HSV range}\par
676             {\cf19 if} (h >= hmin && h <= hmax && s >= smin && s <= smax && v >= vmin && v <= vmax)\par
677             \{\par
678                 datadst[pos_dst] = 255; {\cf20 // Pixel is within range, mark as white}\par
679             \}\par
680             {\cf19 else}\par
681             \{\par
682                 datadst[pos_dst] = 0; {\cf20 // Pixel is outside range, mark as black}\par
683             \}\par
684         \}\par
685     \}\par
686 \par
687     {\cf19 return} 1; {\cf20 // Success}\par
688 \}\par
}
}
{\xe \v vc_hsv_segmentation_castanho\:vc.c}
{\xe \v vc.c\:vc_hsv_segmentation_castanho}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_hsv_segmentation_castanho ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst})}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2273 \{\par
2274     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
2275     {\cf18 int} byterperline_src = src->width * src->channels;\par
2276     {\cf18 int} channels_src = src->channels;\par
2277     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
2278     {\cf18 int} bytesperline_dst = dst->width * dst->channels;\par
2279     {\cf18 int} channels_dst = dst->channels;\par
2280     {\cf18 int} width = src->width;\par
2281     {\cf18 int} height = src->height;\par
2282     {\cf18 int} x, y;\par
2283     {\cf18 long} {\cf18 int} pos_src, pos_dst;\par
2284     {\cf18 float} h, s, v;\par
2285 \par
2286     {\cf19 if} (src->width <= 0 || src->height <= 0 || src->data == NULL)\par
2287         {\cf19 return} 0;\par
2288     {\cf19 if} (src->width != dst->width || src->height != dst->height)\par
2289         {\cf19 return} 0;\par
2290     {\cf19 if} (src->channels != 3 || dst->channels != 1)\par
2291         {\cf19 return} 0;\par
2292 \par
2293     {\cf20 // Segmentation loop}\par
2294     {\cf19 for} (y = 50; y < 158; y++)\par
2295     \{\par
2296         {\cf19 for} (x = 0; x < width; x++)\par
2297         \{\par
2298             pos_src = y * byterperline_src + x * channels_src;\par
2299             pos_dst = y * bytesperline_dst + x * channels_dst;\par
2300 \par
2301             {\cf20 // Assuming HSV values are stored in src and are normalized [0, 255]}\par
2302             h = (int)((({\cf18 float})datasrc[pos_src]) / 255.0f * 360.0f);\par
2303             s = (int)((({\cf18 float})datasrc[pos_src + 1]) / 255.0f * 100.0f);\par
2304             v = (int)((({\cf18 float})datasrc[pos_src + 2]) / 255.0f * 100.0f);\par
2305 \par
2306             {\cf20 // Check if the pixel falls within the specified HSV range}\par
2307             {\cf19 if} ((h >= 10 && h <= 30 && s >= 23 && s <= 46 && v >= 329 && v <= 51) || (h >= 9 && h <= 25 && s >= 39 && s <= 61 && v >= 38 && v <= 61))\par
2308             \{\par
2309                 datadst[pos_dst] = 255; {\cf20 // Pixel is within range, mark as white}\par
2310             \}\par
2311             {\cf19 else}\par
2312             \{\par
2313                 datadst[pos_dst] = 0; {\cf20 // Pixel is outside range, mark as black}\par
2314             \}\par
2315         \}\par
2316     \}\par
2317 \par
2318     {\cf19 return} 1; {\cf20 // Success}\par
2319 \}\par
}
}
{\xe \v vc_hsv_segmentation_final\:vc.c}
{\xe \v vc.c\:vc_hsv_segmentation_final}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_hsv_segmentation_final ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst})}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2322 \{\par
2323     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
2324     {\cf18 int} byterperline_src = src->width * src->channels;\par
2325     {\cf18 int} channels_src = src->channels;\par
2326     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
2327     {\cf18 int} bytesperline_dst = dst->width * dst->channels;\par
2328     {\cf18 int} channels_dst = dst->channels;\par
2329     {\cf18 int} width = src->width;\par
2330     {\cf18 int} height = src->height;\par
2331     {\cf18 int} x, y;\par
2332     {\cf18 long} {\cf18 int} pos_src, pos_dst;\par
2333     {\cf18 float} h, s, v;\par
2334 \par
2335     {\cf19 if} (src->width <= 0 || src->height <= 0 || src->data == NULL)\par
2336         {\cf19 return} 0;\par
2337     {\cf19 if} (src->width != dst->width || src->height != dst->height)\par
2338         {\cf19 return} 0;\par
2339     {\cf19 if} (src->channels != 3 || dst->channels != 1)\par
2340         {\cf19 return} 0;\par
2341 \par
2342     {\cf20 // Segmentation loop}\par
2343     {\cf19 for} (y = 0; y < height; y++)\par
2344     \{\par
2345         {\cf19 for} (x = 0; x < width; x++)\par
2346         \{\par
2347             pos_src = y * byterperline_src + x * channels_src;\par
2348             pos_dst = y * bytesperline_dst + x * channels_dst;\par
2349 \par
2350             {\cf20 // Assuming HSV values are stored in src and are normalized [0, 255]}\par
2351             h = (int)((({\cf18 float})datasrc[pos_src]) / 255.0f * 360.0f);\par
2352             s = (int)((({\cf18 float})datasrc[pos_src + 1]) / 255.0f * 100.0f);\par
2353             v = (int)((({\cf18 float})datasrc[pos_src + 2]) / 255.0f * 100.0f);\par
2354 \par
2355             {\cf20 // Check if the pixel falls within the specified HSV range}\par
2356             {\cf19 if} ((h >= 12 && h <= 28 && s >= 25 && s <= 44 && v >= 31 && v <= 49) || (h >= 11 && h <= 23 && s >= 42 && s <= 58 && v >= 41 && v <= 58) || (h >= 0 && h <= 11 && s >= 45 && s <= 69 && v >= 55 && v <= 89) || (h >= 354 && h <= 360 && s >= 45 && s <= 75 && v >= 55 && v <= 75) || (h >= 79 && h <= 105 && s >= 28 && s <= 45 && v >= 35 && v <= 50) || (h >= 155 && h <= 200 && s >= 16 && s <= 40 && v >= 36 && v <= 52) || (h >= 35 && h <= 200 && s >= 3 && s <= 19 && v >= 15 && v <= 37) || (h >= 6 && h <= 12 && s >= 68 && s <= 78 && v >= 80 && v <= 92) || (h >= 29 && h <= 46 && s >= 31 && s <= 62 && v >= 54 && v <= 91) || (h >= 29 && h <= 38 && s >= 33 && s <= 46 && v >= 46 && v <= 56))\par
2357             \{\par
2358                 datadst[pos_dst] = 255; {\cf20 // Pixel is within range, mark as white}\par
2359             \}\par
2360             {\cf19 else}\par
2361             \{\par
2362                 datadst[pos_dst] = 0; {\cf20 // Pixel is outside range, mark as black}\par
2363             \}\par
2364         \}\par
2365     \}\par
2366 \par
2367     {\cf19 return} 1; {\cf20 // Success}\par
2368 \}\par
}
}
{\xe \v vc_hsv_segmentation_resistencias\:vc.c}
{\xe \v vc.c\:vc_hsv_segmentation_resistencias}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_hsv_segmentation_resistencias ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst})}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2371 \{\par
2372     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
2373     {\cf18 int} byterperline_src = src->width * src->channels;\par
2374     {\cf18 int} channels_src = src->channels;\par
2375     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
2376     {\cf18 int} bytesperline_dst = dst->width * dst->channels;\par
2377     {\cf18 int} channels_dst = dst->channels;\par
2378     {\cf18 int} width = src->width;\par
2379     {\cf18 int} height = src->height;\par
2380     {\cf18 int} x, y;\par
2381     {\cf18 long} {\cf18 int} pos_src, pos_dst;\par
2382     {\cf18 float} h, s, v;\par
2383 \par
2384     {\cf19 if} (src->width <= 0 || src->height <= 0 || src->data == NULL)\par
2385         {\cf19 return} 0;\par
2386     {\cf19 if} (src->width != dst->width || src->height != dst->height)\par
2387         {\cf19 return} 0;\par
2388     {\cf19 if} (src->channels != 3 || dst->channels != 1)\par
2389         {\cf19 return} 0;\par
2390 \par
2391     {\cf20 // Segmentation loop}\par
2392     {\cf19 for} (y = 0; y < height; y++)\par
2393     \{\par
2394         {\cf19 for} (x = 0; x < width; x++)\par
2395         \{\par
2396             pos_src = y * byterperline_src + x * channels_src;\par
2397             pos_dst = y * bytesperline_dst + x * channels_dst;\par
2398 \par
2399             {\cf20 // Assuming HSV values are stored in src and are normalized [0, 255]}\par
2400             h = (int)((({\cf18 float})datasrc[pos_src]) / 255.0f * 360.0f);\par
2401             s = (int)((({\cf18 float})datasrc[pos_src + 1]) / 255.0f * 100.0f);\par
2402             v = (int)((({\cf18 float})datasrc[pos_src + 2]) / 255.0f * 100.0f);\par
2403 \par
2404             {\cf20 // Check if the pixel falls within the specified HSV range}\par
2405             {\cf19 if} ((h >= 12 && h <= 28 && s >= 25 && s <= 44 && v >= 31 && v <= 49) || (h >= 11 && h <= 23 && s >= 42 && s <= 58 && v >= 41 && v <= 58) || (h >= 0 && h <= 11 && s >= 45 && s <= 69 && v >= 55 && v <= 89) || (h >= 354 && h <= 360 && s >= 45 && s <= 75 && v >= 55 && v <= 75) || (h >= 79 && h <= 105 && s >= 28 && s <= 45 && v >= 35 && v <= 50) || (h >= 155 && h <= 200 && s >= 16 && s <= 40 && v >= 36 && v <= 52) || (h >= 35 && h <= 200 && s >= 3 && s <= 19 && v >= 15 && v <= 37) || (h >= 6 && h <= 12 && s >= 68 && s <= 78 && v >= 80 && v <= 92))\par
2406             \{\par
2407                 datadst[pos_dst] = 255; {\cf20 // Pixel is within range, mark as white}\par
2408             \}\par
2409             {\cf19 else}\par
2410             \{\par
2411                 datadst[pos_dst] = 0; {\cf20 // Pixel is outside range, mark as black}\par
2412             \}\par
2413         \}\par
2414     \}\par
2415 \par
2416     {\cf19 return} 1; {\cf20 // Success}\par
2417 \}\par
}
}
{\xe \v vc_hsv_segmentation_vermelho\:vc.c}
{\xe \v vc.c\:vc_hsv_segmentation_vermelho}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_hsv_segmentation_vermelho ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst})}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2224 \{\par
2225     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
2226     {\cf18 int} byterperline_src = src->width * src->channels;\par
2227     {\cf18 int} channels_src = src->channels;\par
2228     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
2229     {\cf18 int} bytesperline_dst = dst->width * dst->channels;\par
2230     {\cf18 int} channels_dst = dst->channels;\par
2231     {\cf18 int} width = src->width;\par
2232     {\cf18 int} height = src->height;\par
2233     {\cf18 int} x, y;\par
2234     {\cf18 long} {\cf18 int} pos_src, pos_dst;\par
2235     {\cf18 float} h, s, v;\par
2236 \par
2237     {\cf19 if} (src->width <= 0 || src->height <= 0 || src->data == NULL)\par
2238         {\cf19 return} 0;\par
2239     {\cf19 if} (src->width != dst->width || src->height != dst->height)\par
2240         {\cf19 return} 0;\par
2241     {\cf19 if} (src->channels != 3 || dst->channels != 1)\par
2242         {\cf19 return} 0;\par
2243 \par
2244     {\cf20 // Segmentation loop}\par
2245     {\cf19 for} (y = 50; y < 158; y++)\par
2246     \{\par
2247         {\cf19 for} (x = 0; x < width; x++)\par
2248         \{\par
2249             pos_src = y * byterperline_src + x * channels_src;\par
2250             pos_dst = y * bytesperline_dst + x * channels_dst;\par
2251 \par
2252             {\cf20 // Assuming HSV values are stored in src and are normalized [0, 255]}\par
2253             h = (int)((({\cf18 float})datasrc[pos_src]) / 255.0f * 360.0f);\par
2254             s = (int)((({\cf18 float})datasrc[pos_src + 1]) / 255.0f * 100.0f);\par
2255             v = (int)((({\cf18 float})datasrc[pos_src + 2]) / 255.0f * 100.0f);\par
2256 \par
2257             {\cf20 // Check if the pixel falls within the specified HSV range}\par
2258             {\cf19 if} ((h >= 0 && h <= 11 && s >= 45 && s <= 69 && v >= 55 && v <= 89) || (h >= 354 && h <= 360 && s >= 45 && s <= 75 && v >= 55 && v <= 75))\par
2259             \{\par
2260                 datadst[pos_dst] = 255; {\cf20 // Pixel is within range, mark as white}\par
2261             \}\par
2262             {\cf19 else}\par
2263             \{\par
2264                 datadst[pos_dst] = 0; {\cf20 // Pixel is outside range, mark as black}\par
2265             \}\par
2266         \}\par
2267     \}\par
2268 \par
2269     {\cf19 return} 1; {\cf20 // Success}\par
2270 \}\par
}
}
{\xe \v vc_image_free\:vc.c}
{\xe \v vc.c\:vc_image_free}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IVC} * vc_image_free ({\b IVC} *  {\i image})}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 53 \{\par
54     {\cf19 if} (image != NULL)\par
55     \{\par
56         {\cf19 if} (image->data != NULL)\par
57         \{\par
58             free(image->data);\par
59             image->data = NULL;\par
60         \}\par
61 \par
62         free(image);\par
63         image = NULL;\par
64     \}\par
65 \par
66     {\cf19 return} image;\par
67 \}\par
}
}
{\xe \v vc_image_new\:vc.c}
{\xe \v vc.c\:vc_image_new}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IVC} * vc_image_new (int  {\i width}, int  {\i height}, int  {\i channels}, int  {\i levels})}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28 \{\par
29     IVC *image = (IVC *)malloc({\cf17 sizeof}(IVC));\par
30 \par
31     {\cf19 if} (image == NULL)\par
32         {\cf19 return} NULL;\par
33     {\cf19 if} ((levels <= 0) || (levels > 255))\par
34         {\cf19 return} NULL;\par
35 \par
36     image->width = width;\par
37     image->height = height;\par
38     image->channels = channels;\par
39     image->levels = levels;\par
40     image->bytesperline = image->width * image->channels;\par
41     image->data = ({\cf18 unsigned} {\cf18 char} *)malloc(image->width * image->height * image->channels * {\cf17 sizeof}({\cf18 char}));\par
42 \par
43     {\cf19 if} (image->data == NULL)\par
44     \{\par
45         {\cf19 return} vc_image_free(image);\par
46     \}\par
47 \par
48     {\cf19 return} image;\par
49 \}\par
}
}
{\xe \v vc_read_image\:vc.c}
{\xe \v vc.c\:vc_read_image}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IVC} * vc_read_image (char *  {\i filename})}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 193 \{\par
194     FILE *file = NULL;\par
195     IVC *image = NULL;\par
196     {\cf18 unsigned} {\cf18 char} *tmp;\par
197     {\cf18 char} tok[20];\par
198     {\cf18 long} {\cf18 int} size, sizeofbinarydata;\par
199     {\cf18 int} width, height, channels;\par
200     {\cf18 int} levels = 255;\par
201     {\cf18 int} v;\par
202 \par
203     {\cf20 // Abre o ficheiro}\par
204     {\cf19 if} ((file = fopen(filename, {\cf22 "rb"})) != NULL)\par
205     \{\par
206         {\cf20 // Efectua a leitura do header}\par
207         netpbm_get_token(file, tok, {\cf17 sizeof}(tok));\par
208 \par
209         {\cf19 if} (strcmp(tok, {\cf22 "P4"}) == 0)\par
210         \{\par
211             channels = 1;\par
212             levels = 1;\par
213         \} {\cf20 // Se PBM (Binary [0,1])}\par
214         {\cf19 else} {\cf19 if} (strcmp(tok, {\cf22 "P5"}) == 0)\par
215             channels = 1; {\cf20 // Se PGM (Gray [0,MY_MAX(level,255)])}\par
216         {\cf19 else} {\cf19 if} (strcmp(tok, {\cf22 "P6"}) == 0)\par
217             channels = 3; {\cf20 // Se PPM (RGB [0,MY_MAX(level,255)])}\par
218         {\cf19 else}\par
219         \{\par
220 {\cf21 #ifdef VC_DEBUG}\par
221             printf({\cf22 "ERROR -> vc_read_image():\\n\\tFile is not a valid PBM, PGM or PPM file.\\n\\tBad magic number!\\n"});\par
222 {\cf21 #endif}\par
223 \par
224             fclose(file);\par
225             {\cf19 return} NULL;\par
226         \}\par
227 \par
228         {\cf19 if} (levels == 1) {\cf20 // PBM}\par
229         \{\par
230             {\cf19 if} (sscanf(netpbm_get_token(file, tok, {\cf17 sizeof}(tok)), {\cf22 "%d"}, &width) != 1 ||\par
231                 sscanf(netpbm_get_token(file, tok, {\cf17 sizeof}(tok)), {\cf22 "%d"}, &height) != 1)\par
232             \{\par
233 {\cf21 #ifdef VC_DEBUG}\par
234                 printf({\cf22 "ERROR -> vc_read_image():\\n\\tFile is not a valid PBM file.\\n\\tBad size!\\n"});\par
235 {\cf21 #endif}\par
236 \par
237                 fclose(file);\par
238                 {\cf19 return} NULL;\par
239             \}\par
240 \par
241             {\cf20 // Aloca mem\'EF\'BF\'BDria para imagem}\par
242             image = vc_image_new(width, height, channels, levels);\par
243             {\cf19 if} (image == NULL)\par
244                 {\cf19 return} NULL;\par
245 \par
246             sizeofbinarydata = (image->width / 8 + ((image->width % 8) ? 1 : 0)) * image->height;\par
247             tmp = ({\cf18 unsigned} {\cf18 char} *)malloc(sizeofbinarydata);\par
248             {\cf19 if} (tmp == NULL)\par
249                 {\cf19 return} 0;\par
250 \par
251 {\cf21 #ifdef VC_DEBUG}\par
252             printf({\cf22 "\\nchannels=%d w=%d h=%d levels=%d\\n"}, image->channels, image->width, image->height, levels);\par
253 {\cf21 #endif}\par
254 \par
255             {\cf19 if} ((v = fread(tmp, {\cf17 sizeof}({\cf18 unsigned} {\cf18 char}), sizeofbinarydata, file)) != sizeofbinarydata)\par
256             \{\par
257 {\cf21 #ifdef VC_DEBUG}\par
258                 printf({\cf22 "ERROR -> vc_read_image():\\n\\tPremature EOF on file.\\n"});\par
259 {\cf21 #endif}\par
260 \par
261                 vc_image_free(image);\par
262                 fclose(file);\par
263                 free(tmp);\par
264                 {\cf19 return} NULL;\par
265             \}\par
266 \par
267             bit_to_unsigned_char(tmp, image->data, image->width, image->height);\par
268 \par
269             free(tmp);\par
270         \}\par
271         {\cf19 else} {\cf20 // PGM ou PPM}\par
272         \{\par
273             {\cf19 if} (sscanf(netpbm_get_token(file, tok, {\cf17 sizeof}(tok)), {\cf22 "%d"}, &width) != 1 ||\par
274                 sscanf(netpbm_get_token(file, tok, {\cf17 sizeof}(tok)), {\cf22 "%d"}, &height) != 1 ||\par
275                 sscanf(netpbm_get_token(file, tok, {\cf17 sizeof}(tok)), {\cf22 "%d"}, &levels) != 1 || levels <= 0 || levels > 255)\par
276             \{\par
277 {\cf21 #ifdef VC_DEBUG}\par
278                 printf({\cf22 "ERROR -> vc_read_image():\\n\\tFile is not a valid PGM or PPM file.\\n\\tBad size!\\n"});\par
279 {\cf21 #endif}\par
280 \par
281                 fclose(file);\par
282                 {\cf19 return} NULL;\par
283             \}\par
284 \par
285             {\cf20 // Aloca mem\'EF\'BF\'BDria para imagem}\par
286             image = vc_image_new(width, height, channels, levels);\par
287             {\cf19 if} (image == NULL)\par
288                 {\cf19 return} NULL;\par
289 \par
290 {\cf21 #ifdef VC_DEBUG}\par
291             printf({\cf22 "\\nchannels=%d w=%d h=%d levels=%d\\n"}, image->channels, image->width, image->height, levels);\par
292 {\cf21 #endif}\par
293 \par
294             size = image->width * image->height * image->channels;\par
295 \par
296             {\cf19 if} ((v = fread(image->data, {\cf17 sizeof}({\cf18 unsigned} {\cf18 char}), size, file)) != size)\par
297             \{\par
298 {\cf21 #ifdef VC_DEBUG}\par
299                 printf({\cf22 "ERROR -> vc_read_image():\\n\\tPremature EOF on file.\\n"});\par
300 {\cf21 #endif}\par
301 \par
302                 vc_image_free(image);\par
303                 fclose(file);\par
304                 {\cf19 return} NULL;\par
305             \}\par
306         \}\par
307 \par
308         fclose(file);\par
309     \}\par
310     {\cf19 else}\par
311     \{\par
312 {\cf21 #ifdef VC_DEBUG}\par
313         printf({\cf22 "ERROR -> vc_read_image():\\n\\tFile not found.\\n"});\par
314 {\cf21 #endif}\par
315     \}\par
316 \par
317     {\cf19 return} image;\par
318 \}\par
}
}
{\xe \v vc_rgb_get_blue_gray\:vc.c}
{\xe \v vc.c\:vc_rgb_get_blue_gray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_rgb_get_blue_gray ({\b IVC} *  {\i srcdst})}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 498 \{\par
499     {\cf18 unsigned} {\cf18 char} *data = ({\cf18 unsigned} {\cf18 char} *)srcdst->data;\par
500     {\cf18 int} width = srcdst->width;\par
501     {\cf18 int} height = srcdst->height;\par
502     {\cf18 int} bytesperline = srcdst->width * srcdst->channels;\par
503     {\cf18 int} channels = srcdst->channels;\par
504     {\cf18 int} x, y;\par
505     {\cf18 long} {\cf18 int} pos;\par
506 \par
507     {\cf20 // Verifica\'E7\'E3o de erros}\par
508     if ((srcdst->width <= 0) || (srcdst->height <= 0) || (srcdst->data == NULL))\par
509         {\cf19 return} 0;\par
510     {\cf19 if} (channels != 3)\par
511         {\cf19 return} 0;\par
512 \par
513     {\cf20 // Extrai a componente RED}\par
514     {\cf19 for} (y = 0; y < height; y++)\par
515     \{\par
516         {\cf19 for} (x = 0; x < width; x++)\par
517         \{\par
518             pos = y * bytesperline + x * channels;\par
519 \par
520             data[pos] = data[pos + 2];\par
521             data[pos + 1] = data[pos + 2];\par
522         \}\par
523     \}\par
524 \par
525     {\cf19 return} 1;\par
526 \};\par
}
}
{\xe \v vc_rgb_get_green_gray\:vc.c}
{\xe \v vc.c\:vc_rgb_get_green_gray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_rgb_get_green_gray ({\b IVC} *  {\i srcdst})}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 467 \{\par
468     {\cf18 unsigned} {\cf18 char} *data = ({\cf18 unsigned} {\cf18 char} *)srcdst->data;\par
469     {\cf18 int} width = srcdst->width;\par
470     {\cf18 int} height = srcdst->height;\par
471     {\cf18 int} bytesperline = srcdst->width * srcdst->channels;\par
472     {\cf18 int} channels = srcdst->channels;\par
473     {\cf18 int} x, y;\par
474     {\cf18 long} {\cf18 int} pos;\par
475 \par
476     {\cf20 // Verifica\'E7\'E3o de erros}\par
477     if ((srcdst->width <= 0) || (srcdst->height <= 0) || (srcdst->data == NULL))\par
478         {\cf19 return} 0;\par
479     {\cf19 if} (channels != 3)\par
480         {\cf19 return} 0;\par
481 \par
482     {\cf20 // Extrai a componente RED}\par
483     {\cf19 for} (y = 0; y < height; y++)\par
484     \{\par
485         {\cf19 for} (x = 0; x < width; x++)\par
486         \{\par
487             pos = y * bytesperline + x * channels;\par
488 \par
489             data[pos] = data[pos + 1];\par
490             data[pos + 2] = data[pos + 1];\par
491         \}\par
492     \}\par
493 \par
494     {\cf19 return} 1;\par
495 \};\par
}
}
{\xe \v vc_rgb_get_red_gray\:vc.c}
{\xe \v vc.c\:vc_rgb_get_red_gray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_rgb_get_red_gray ({\b IVC} *  {\i srcdst})}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 436 \{\par
437     {\cf18 unsigned} {\cf18 char} *data = ({\cf18 unsigned} {\cf18 char} *)srcdst->data;\par
438     {\cf18 int} width = srcdst->width;\par
439     {\cf18 int} height = srcdst->height;\par
440     {\cf18 int} bytesperline = srcdst->width * srcdst->channels;\par
441     {\cf18 int} channels = srcdst->channels;\par
442     {\cf18 int} x, y;\par
443     {\cf18 long} {\cf18 int} pos;\par
444 \par
445     {\cf20 // Verifica\'E7\'E3o de erros}\par
446     if ((srcdst->width <= 0) || (srcdst->height <= 0) || (srcdst->data == NULL))\par
447         {\cf19 return} 0;\par
448     {\cf19 if} (channels != 3)\par
449         {\cf19 return} 0;\par
450 \par
451     {\cf20 // Extrai a componente RED}\par
452     {\cf19 for} (y = 0; y < height; y++)\par
453     \{\par
454         {\cf19 for} (x = 0; x < width; x++)\par
455         \{\par
456             pos = y * bytesperline + x * channels;\par
457 \par
458             data[pos + 1] = data[pos]; {\cf20 // Green}\par
459             data[pos + 2] = data[pos]; {\cf20 // Blue}\par
460         \}\par
461     \}\par
462 \par
463     {\cf19 return} 1;\par
464 \};\par
}
}
{\xe \v vc_rgb_negative\:vc.c}
{\xe \v vc.c\:vc_rgb_negative}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_rgb_negative ({\b IVC} *  {\i srcdst})}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 406 \{\par
407     {\cf18 unsigned} {\cf18 char} *data = ({\cf18 unsigned} {\cf18 char} *)srcdst->data;\par
408     {\cf18 int} width = srcdst->width;\par
409     {\cf18 int} height = srcdst->height;\par
410     {\cf18 int} bytesperline = srcdst->width * srcdst->channels;\par
411     {\cf18 int} channels = srcdst->channels;\par
412     {\cf18 int} x, y;\par
413     {\cf18 long} {\cf18 int} pos;\par
414 \par
415     if ((srcdst->width <= 0) || (srcdst->height <= 0) || (srcdst->data == NULL))\par
416         {\cf19 return} 0;\par
417     {\cf19 if} (channels != 3)\par
418         {\cf19 return} 0;\par
419 \par
420     {\cf19 for} (y = 0; y < height; y++)\par
421     \{\par
422         {\cf19 for} (x = 0; x < width; x++)\par
423         \{\par
424             pos = y * bytesperline + x * channels;\par
425 \par
426             data[pos] = 255 - data[pos];\par
427             data[pos + 1] = 255 - data[pos + 1];\par
428             data[pos + 2] = 255 - data[pos + 2];\par
429         \}\par
430     \}\par
431 \par
432     {\cf19 return} 1;\par
433 \}\par
}
}
{\xe \v vc_rgb_to_gray\:vc.c}
{\xe \v vc.c\:vc_rgb_to_gray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_rgb_to_gray ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst})}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 529 \{\par
530     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
531     {\cf18 int} byterperline_src = src->width * src->channels;\par
532     {\cf18 int} channels_src = src->channels;\par
533     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
534     {\cf18 int} bytesperline_dst = dst->width * dst->channels;\par
535     {\cf18 int} channels_dst = dst->channels;\par
536     {\cf18 int} width = src->width;\par
537     {\cf18 int} height = src->height;\par
538     {\cf18 int} x, y;\par
539     {\cf18 long} {\cf18 int} pos_src, pos_dst;\par
540     {\cf18 float} rf, gf, bf;\par
541 \par
542     {\cf19 if} (src->width <= 0 || src->height <= 0 || src->data == NULL)\par
543         {\cf19 return} 0;\par
544     {\cf19 if} (src->width != dst->width || src->height != dst->height)\par
545         {\cf19 return} 0;\par
546     {\cf19 if} (src->channels != 3 || dst->channels != 1)\par
547         {\cf19 return} 0;\par
548 \par
549     {\cf19 for} (y = 0; y < height; y++)\par
550     \{\par
551         {\cf19 for} (x = 0; x < width; x++)\par
552         \{\par
553             pos_src = y * byterperline_src + x * channels_src;\par
554             pos_dst = y * bytesperline_dst + x * channels_dst;\par
555 \par
556             rf = (float)datasrc[pos_src];\par
557             gf = (float)datasrc[pos_src + 1];\par
558             bf = (float)datasrc[pos_src + 2];\par
559 \par
560             datadst[pos_dst] = ({\cf18 unsigned} char)((rf * 0.299) + (gf * 0.587) + (bf * 0.114));\par
561         \}\par
562     \}\par
563     {\cf19 return} 1;\par
564 \}\par
}
}
{\xe \v vc_rgb_to_hsv\:vc.c}
{\xe \v vc.c\:vc_rgb_to_hsv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_rgb_to_hsv ({\b IVC} *  {\i srcdst})}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 567 \{\par
568     {\cf18 unsigned} {\cf18 char} *data = ({\cf18 unsigned} {\cf18 char} *)srcdst->data;\par
569     {\cf18 int} width = srcdst->width;\par
570     {\cf18 int} height = srcdst->height;\par
571     {\cf18 int} bytesperline = srcdst->bytesperline;\par
572     {\cf18 int} channels = srcdst->channels;\par
573     {\cf18 float} r, g, b, saturation, hue, value;\par
574     {\cf18 int} i, size;\par
575     {\cf18 int} pos_src;\par
576     {\cf18 float} rgb_max;\par
577     {\cf18 float} rgb_min;\par
578 \par
579     if ((srcdst->width <= 0) || (srcdst->height <= 0) || (srcdst->data == NULL))\par
580         {\cf19 return} 0;\par
581     {\cf19 if} (channels != 3)\par
582         {\cf19 return} 0;\par
583 \par
584     size = width * height * channels;\par
585 \par
586     {\cf19 for} (i = 0; i < size; i += channels)\par
587     \{\par
588         pos_src = i;\par
589 \par
590         r = (float)data[pos_src];\par
591         g = (float)data[pos_src + 1];\par
592         b = (float)data[pos_src + 2];\par
593 \par
594         rgb_max = fmaxf(r, fmaxf(g, b));\par
595         rgb_min = fminf(r, fminf(g, b));\par
596 \par
597         value = rgb_max;\par
598 \par
599         {\cf19 if} (value == 0.0f)\par
600         \{\par
601             hue = 0.0f;\par
602             saturation = 0.0f;\par
603         \}\par
604         {\cf19 else}\par
605         \{\par
606             saturation = ((rgb_max - rgb_min) / rgb_max) * 255.0f;\par
607 \par
608             {\cf19 if} (saturation == 0.0f)\par
609             \{\par
610                 hue = 0.0f;\par
611             \}\par
612             {\cf19 else}\par
613             \{\par
614                 {\cf19 if} ((rgb_max == r) && (g >= b))\par
615                 \{\par
616                     hue = 60.0f * (g - b) / (rgb_max - rgb_min);\par
617                 \}\par
618                 {\cf19 else} {\cf19 if} ((rgb_max == r) && (b > g))\par
619                 \{\par
620                     hue = 360 + 60 * (g - b) / (rgb_max - rgb_min);\par
621                 \}\par
622                 {\cf19 else} {\cf19 if} (rgb_max == g)\par
623                 \{\par
624                     hue = 120 + 60 * (b - r) / (rgb_max - rgb_min);\par
625                 \}\par
626                 {\cf19 else} {\cf19 if} (rgb_max == b)\par
627                 \{\par
628                     hue = 240 + 60 * (r - g) / (rgb_max - rgb_min);\par
629                 \}\par
630             \}\par
631         \}\par
632 \par
633         data[i] = ({\cf18 unsigned} char)(hue / 360.0f * 255.0f);\par
634         data[i + 1] = ({\cf18 unsigned} char)(saturation);\par
635         data[i + 2] = ({\cf18 unsigned} char)(value);\par
636     \}\par
637 \par
638     {\cf19 return} 1;\par
639 \}\par
}
}
{\xe \v vc_scale_gray_to_rgb\:vc.c}
{\xe \v vc.c\:vc_scale_gray_to_rgb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_scale_gray_to_rgb ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst})}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 691 \{\par
692     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
693     {\cf18 int} byterperline_src = src->width * src->channels;\par
694     {\cf18 int} channels_src = src->channels;\par
695     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
696     {\cf18 int} bytesperline_dst = dst->width * dst->channels;\par
697     {\cf18 int} channels_dst = dst->channels;\par
698     {\cf18 int} width = src->width;\par
699     {\cf18 int} height = src->height;\par
700     {\cf18 int} x, y;\par
701     {\cf18 long} {\cf18 int} pos_src, pos_dst;\par
702     {\cf18 unsigned} {\cf18 char} gray, red, green, blue;\par
703 \par
704     {\cf20 // Check for valid conditions}\par
705     {\cf19 if} (src->width <= 0 || src->height <= 0 || src->data == NULL)\par
706         {\cf19 return} 0;\par
707     {\cf19 if} (src->width != dst->width || src->height != dst->height)\par
708         {\cf19 return} 0;\par
709     {\cf19 if} (src->channels != 1 || dst->channels != 3)\par
710         {\cf19 return} 0;\par
711 \par
712     {\cf19 for} ({\cf18 int} y = 0; y < height; y++)\par
713     \{\par
714         {\cf19 for} ({\cf18 int} x = 0; x < width; x++)\par
715         \{\par
716             pos_src = y * byterperline_src + x * channels_src;\par
717             pos_dst = y * bytesperline_dst + x * channels_dst;\par
718 \par
719             gray = datasrc[pos_src];\par
720 \par
721             {\cf19 if} (gray < 128)\par
722                 red = 0;\par
723             {\cf19 else} {\cf19 if} (gray >= 128 && gray <= 192)\par
724                 red = ({\cf18 unsigned} char)(((gray - 128) / 64.0) * 255);\par
725             {\cf19 else}\par
726                 red = 255;\par
727 \par
728             {\cf19 if} (gray <= 64)\par
729                 green = ({\cf18 unsigned} char)((gray / 64.0) * 255);\par
730             {\cf19 else} {\cf19 if} (gray > 64 && gray <= 192)\par
731                 green = 255;\par
732             {\cf19 else}\par
733                 green = ({\cf18 unsigned} char)(((255 - gray) / 63.0) * 255);\par
734 \par
735             {\cf19 if} (gray <= 64)\par
736                 blue = 255;\par
737             {\cf19 else} {\cf19 if} (gray > 64 && gray <= 128)\par
738                 blue = ({\cf18 unsigned} char)(((128 - gray) / 64.0) * 255);\par
739             {\cf19 else}\par
740                 blue = 0;\par
741 \par
742             datadst[pos_dst] = red;\par
743             datadst[pos_dst + 1] = green;\par
744             datadst[pos_dst + 2] = blue;\par
745         \}\par
746     \}\par
747 \par
748     {\cf19 return} 1;\par
749 \}\par
}
}
{\xe \v vc_white_pixels_quantitie\:vc.c}
{\xe \v vc.c\:vc_white_pixels_quantitie}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_white_pixels_quantitie ({\b IVC} *  {\i srcdst})}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 779 \{\par
780     {\cf18 unsigned} {\cf18 char} *data = ({\cf18 unsigned} {\cf18 char} *)srcdst->data;\par
781     {\cf18 int} width = srcdst->width;\par
782     {\cf18 int} height = srcdst->height;\par
783     {\cf18 int} bytesperline = srcdst->width * srcdst->channels;\par
784     {\cf18 int} channels = srcdst->channels;\par
785     {\cf18 int} x, y, w;\par
786     {\cf18 long} {\cf18 int} pos;\par
787     w = 0;\par
788 \par
789     if ((srcdst->width <= 0) || (srcdst->height <= 0) || (srcdst->data == NULL))\par
790         {\cf19 return} 0;\par
791 \par
792     {\cf19 for} (y = 0; y < height; y++)\par
793     \{\par
794         {\cf19 for} (x = 0; x < width; x++)\par
795         \{\par
796             pos = y * bytesperline + x * channels;\par
797 \par
798             {\cf19 if} (data[pos] == 255)\par
799             \{\par
800                 w++;\par
801             \}\par
802         \}\par
803     \}\par
804     {\cf19 return} w;\par
805 \}\par
}
}
{\xe \v vc_write_image\:vc.c}
{\xe \v vc.c\:vc_write_image}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_write_image (char *  {\i filename}, {\b IVC} *  {\i image})}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 321 \{\par
322     FILE *file = NULL;\par
323     {\cf18 unsigned} {\cf18 char} *tmp;\par
324     {\cf18 long} {\cf18 int} totalbytes, sizeofbinarydata;\par
325 \par
326     {\cf19 if} (image == NULL)\par
327         {\cf19 return} 0;\par
328 \par
329     {\cf19 if} ((file = fopen(filename, {\cf22 "wb"})) != NULL)\par
330     \{\par
331         {\cf19 if} (image->levels == 1)\par
332         \{\par
333             sizeofbinarydata = (image->width / 8 + ((image->width % 8) ? 1 : 0)) * image->height + 1;\par
334             tmp = ({\cf18 unsigned} {\cf18 char} *)malloc(sizeofbinarydata);\par
335             {\cf19 if} (tmp == NULL)\par
336                 {\cf19 return} 0;\par
337 \par
338             fprintf(file, {\cf22 "%s %d %d\\n"}, {\cf22 "P4"}, image->width, image->height);\par
339 \par
340             totalbytes = unsigned_char_to_bit(image->data, tmp, image->width, image->height);\par
341             printf({\cf22 "Total = %ld\\n"}, totalbytes);\par
342             {\cf19 if} (fwrite(tmp, {\cf17 sizeof}({\cf18 unsigned} {\cf18 char}), totalbytes, file) != totalbytes)\par
343             \{\par
344 {\cf21 #ifdef VC_DEBUG}\par
345                 fprintf(stderr, {\cf22 "ERROR -> vc_read_image():\\n\\tError writing PBM, PGM or PPM file.\\n"});\par
346 {\cf21 #endif}\par
347 \par
348                 fclose(file);\par
349                 free(tmp);\par
350                 {\cf19 return} 0;\par
351             \}\par
352 \par
353             free(tmp);\par
354         \}\par
355         {\cf19 else}\par
356         \{\par
357             fprintf(file, {\cf22 "%s %d %d 255\\n"}, (image->channels == 1) ? {\cf22 "P5"} : {\cf22 "P6"}, image->width, image->height);\par
358 \par
359             {\cf19 if} (fwrite(image->data, image->bytesperline, image->height, file) != image->height)\par
360             \{\par
361 {\cf21 #ifdef VC_DEBUG}\par
362                 fprintf(stderr, {\cf22 "ERROR -> vc_read_image():\\n\\tError writing PBM, PGM or PPM file.\\n"});\par
363 {\cf21 #endif}\par
364 \par
365                 fclose(file);\par
366                 {\cf19 return} 0;\par
367             \}\par
368         \}\par
369 \par
370         fclose(file);\par
371 \par
372         {\cf19 return} 1;\par
373     \}\par
374 \par
375     {\cf19 return} 0;\par
376 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Program Files (x86)/VisaoComputador_TP/CodigoFonte/vc.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Program Files (x86)/VisaoComputador_TP/CodigoFonte/vc.h}
{\xe \v C:/Program Files (x86)/VisaoComputador_TP/CodigoFonte/vc.h}
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b IVC}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b OVC}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VC_DEBUG}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MY_MAX}(a,  b)\~ (a > b ? a : b)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MY_MIN}(a,  b)\~ (a < b ? a : b)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IVC} * {\b vc_image_new} (int width, int height, int channels, int levels)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IVC} * {\b vc_image_free} ({\b IVC} *image)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IVC} * {\b vc_read_image} (char *filename)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_write_image} (char *filename, {\b IVC} *image)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_gray_negative} ({\b IVC} *srcdst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_rgb_negative} ({\b IVC} *srcdst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_rgb_get_red_gray} ({\b IVC} *srcdst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_rgb_get_green_gray} ({\b IVC} *srcdst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_rgb_get_blue_gray} ({\b IVC} *srcdst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_rgb_to_gray} ({\b IVC} *src, {\b IVC} *dst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_rgb_to_hsv} ({\b IVC} *srcdst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_hsv_segmentation} ({\b IVC} *src, {\b IVC} *dst, int hmin, int hmax, int smin, int smax, int vmin, int vmax)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_scale_gray_to_rgb} ({\b IVC} *src, {\b IVC} *dst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b combine_segmentations} ({\b IVC} *dst, {\b IVC} *src1, {\b IVC} *src2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_white_pixels_quantitie} ({\b IVC} *srcdst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_gray_to_binary} ({\b IVC} *srcdst, int threshold)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_gray_to_binary_global_mean} ({\b IVC} *srcdst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_gray_to_binary_midpoint} ({\b IVC} *src, {\b IVC} *dst, int kernel)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_gray_to_binary_bernsen} ({\b IVC} *src, {\b IVC} *dst, int kernel, int cmin)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_gray_to_binary_niblack} ({\b IVC} *src, {\b IVC} *dst, int kernel, float k)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_binary_dilate} ({\b IVC} *src, {\b IVC} *dst, int kernel)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_binary_erode} ({\b IVC} *src, {\b IVC} *dst, int kernel)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_binary_open} ({\b IVC} *src, {\b IVC} *dst, int kernel)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_binary_close} ({\b IVC} *src, {\b IVC} *dst, int kernel)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_gray_dilate} ({\b IVC} *src, {\b IVC} *dst, int kernel)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_gray_erode} ({\b IVC} *src, {\b IVC} *dst, int kernel)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_gray_open} ({\b IVC} *src, {\b IVC} *dst, int kernel)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_gray_close} ({\b IVC} *src, {\b IVC} *dst, int kernel)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b combine_segmentations2} ({\b IVC} *dst, {\b IVC} *src1, {\b IVC} *src2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b brancoparaoriginal} ({\b IVC} *dst, {\b IVC} *src1, {\b IVC} *src2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b OVC} * {\b vc_binary_blob_labelling} ({\b IVC} *src, {\b IVC} *dst, int *nlabels)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_binary_blob_info} ({\b IVC} *src, {\b OVC} *blobs, int nblobs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_coloring} ({\b IVC} *src, {\b IVC} *dst, int nlabels)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_draw_boundingbox} ({\b IVC} *srcdst, {\b OVC} *blobs, int nblobs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_draw_centerofgravity} ({\b IVC} *srcdst, {\b OVC} *blobs, int nblobs, int s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_gray_histogram_show} ({\b IVC} *src, {\b IVC} *dst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_gray_histogram_equalization} ({\b IVC} *src, {\b IVC} *dst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_gray_edge_prewitt} ({\b IVC} *src, {\b IVC} *dst, float th)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_bgr_to_rgb} ({\b IVC} *srcdst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_bgr_to_hsv} ({\b IVC} *srcdst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b brancoparaoriginal_trabalho} ({\b IVC} *dst, {\b IVC} *src1, {\b IVC} *src2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_hsv_segmentation_vermelho} ({\b IVC} *src, {\b IVC} *dst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_hsv_segmentation_castanho} ({\b IVC} *src, {\b IVC} *dst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_hsv_segmentation_final} ({\b IVC} *src, {\b IVC} *dst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_hsv_segmentation_resistencias} ({\b IVC} *src, {\b IVC} *dst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lookForWhite} ({\b IVC} *src, int yc, int *widths)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b comparePixelsAtPosition} ({\b IVC} *src1, {\b IVC} *src2, int yc, int width)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b vc_bgr_to_hsv2} ({\b IVC} *src, {\b IVC} *dst)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v MY_MAX\:vc.h}
{\xe \v vc.h\:MY_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MY_MAX( a,  b)\~ (a > b ? a : b)}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MY_MIN\:vc.h}
{\xe \v vc.h\:MY_MIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MY_MIN( a,  b)\~ (a < b ? a : b)}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v VC_DEBUG\:vc.h}
{\xe \v vc.h\:VC_DEBUG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VC_DEBUG}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v brancoparaoriginal\:vc.h}
{\xe \v vc.h\:brancoparaoriginal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void brancoparaoriginal ({\b IVC} *  {\i dst}, {\b IVC} *  {\i src1}, {\b IVC} *  {\i src2})}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1375 \{\par
1376     {\cf19 if} (src1->width != src2->width || src1->height != src2->height)\par
1377     \{\par
1378         printf({\cf22 "ERROR -> combine_segmentations():\\n\\tImages size mismatch!\\n"});\par
1379         {\cf19 return};\par
1380     \}\par
1381 \par
1382     {\cf19 for} ({\cf18 int} y = 0; y < src1->height; y++)\par
1383     \{\par
1384         {\cf19 for} ({\cf18 int} x = 0; x < src1->width; x++)\par
1385         \{\par
1386             {\cf18 int} pos = y * (src1->width) + x; {\cf20 // Assume imagens de destino s\'E3o monocrom\'E1ticas}\par
1387 \par
1388             {\cf19 if} (src1->data[pos] == 255)\par
1389             \{\par
1390                 dst->data[pos] = src2->data[pos];\par
1391             \}\par
1392             {\cf19 else}\par
1393             \{\par
1394                 dst->data[pos] = 0;\par
1395             \}\par
1396         \}\par
1397     \}\par
1398 \}\par
}
}
{\xe \v brancoparaoriginal_trabalho\:vc.h}
{\xe \v vc.h\:brancoparaoriginal_trabalho}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void brancoparaoriginal_trabalho ({\b IVC} *  {\i dst}, {\b IVC} *  {\i src1}, {\b IVC} *  {\i src2})}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2172 \{\par
2173     {\cf19 if} (src1->width != src2->width || src1->height != src2->height)\par
2174     \{\par
2175         printf({\cf22 "ERROR -> brancoparaoriginal_trabalho():\\n\\tImages size mismatch!\\n"});\par
2176         {\cf19 return};\par
2177     \}\par
2178 \par
2179     {\cf19 if} (src1->channels != 1 || src2->channels != 3 || dst->channels != 3)\par
2180     \{\par
2181         printf({\cf22 "ERROR -> brancoparaoriginal_trabalho():\\n\\tChannel number mismatch!\\n"});\par
2182         {\cf19 return};\par
2183     \}\par
2184 \par
2185     {\cf18 int} start = 150;\par
2186     {\cf18 int} end = src1->width - 150;\par
2187 \par
2188     {\cf19 for} ({\cf18 int} y = 0; y < src1->height; y++)\par
2189     \{\par
2190         {\cf19 for} ({\cf18 int} x = 0; x < src1->width; x++)\par
2191         \{\par
2192             {\cf18 int} posSrc1 = y * src1->bytesperline + x;     {\cf20 // Position in the binary image}\par
2193             {\cf18 int} posSrc2 = y * src2->bytesperline + 3 * x; {\cf20 // Position in the 3-channel image}\par
2194 \par
2195             {\cf19 if} (x >= start && x < end)\par
2196             \{\par
2197                 {\cf19 if} (src1->data[posSrc1] == 255)\par
2198                 \{\par
2199                     {\cf20 // Set dst pixels to white if src1's corresponding pixel is 255 within specified range}\par
2200                     dst->data[posSrc2] = 255;\par
2201                     dst->data[posSrc2 + 1] = 255;\par
2202                     dst->data[posSrc2 + 2] = 255;\par
2203                 \}\par
2204                 {\cf19 else}\par
2205                 \{\par
2206                     {\cf20 // Copy pixel from src2 to dst within specified range}\par
2207                     dst->data[posSrc2] = src2->data[posSrc2];\par
2208                     dst->data[posSrc2 + 1] = src2->data[posSrc2 + 1];\par
2209                     dst->data[posSrc2 + 2] = src2->data[posSrc2 + 2];\par
2210                 \}\par
2211             \}\par
2212             {\cf19 else}\par
2213             \{\par
2214                 {\cf20 // Copy pixel from src2 to dst outside specified range}\par
2215                 dst->data[posSrc2] = src2->data[posSrc2];\par
2216                 dst->data[posSrc2 + 1] = src2->data[posSrc2 + 1];\par
2217                 dst->data[posSrc2 + 2] = src2->data[posSrc2 + 2];\par
2218             \}\par
2219         \}\par
2220     \}\par
2221 \}\par
}
}
{\xe \v combine_segmentations\:vc.h}
{\xe \v vc.h\:combine_segmentations}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void combine_segmentations ({\b IVC} *  {\i dst}, {\b IVC} *  {\i src1}, {\b IVC} *  {\i src2})}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 752 \{\par
753     {\cf19 if} (src1->width != src2->width || src1->height != src2->height)\par
754     \{\par
755         printf({\cf22 "ERROR -> combine_segmentations():\\n\\tImages size mismatch!\\n"});\par
756         {\cf19 return};\par
757     \}\par
758 \par
759     {\cf19 for} ({\cf18 int} y = 0; y < src1->height; y++)\par
760     \{\par
761         {\cf19 for} ({\cf18 int} x = 0; x < src1->width; x++)\par
762         \{\par
763             {\cf18 int} pos = y * (src1->width) + x; {\cf20 // Assume imagens de destino s\'E3o monocrom\'E1ticas}\par
764 \par
765             {\cf20 // Se algum dos pixels nas imagens tempor\'E1rias for branco, defina o correspondente em dst como branco}\par
766             {\cf19 if} (src1->data[pos] == 255 || src2->data[pos] == 255)\par
767             \{\par
768                 dst->data[pos] = 255;\par
769             \}\par
770             {\cf19 else}\par
771             \{\par
772                 dst->data[pos] = 0;\par
773             \}\par
774         \}\par
775     \}\par
776 \}\par
}
}
{\xe \v combine_segmentations2\:vc.h}
{\xe \v vc.h\:combine_segmentations2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void combine_segmentations2 ({\b IVC} *  {\i dst}, {\b IVC} *  {\i src1}, {\b IVC} *  {\i src2})}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1344 \{\par
1345     {\cf19 if} (src1->width != src2->width || src1->height != src2->height)\par
1346     \{\par
1347         printf({\cf22 "ERROR -> combine_segmentations():\\n\\tImages size mismatch!\\n"});\par
1348         {\cf19 return};\par
1349     \}\par
1350 \par
1351     {\cf19 for} ({\cf18 int} y = 0; y < src1->height; y++)\par
1352     \{\par
1353         {\cf19 for} ({\cf18 int} x = 0; x < src1->width; x++)\par
1354         \{\par
1355             {\cf18 int} pos = y * (src1->width) + x; {\cf20 // Assume imagens de destino s\'E3o monocrom\'E1ticas}\par
1356 \par
1357             {\cf20 // Se algum dos pixels nas imagens tempor\'E1rias for branco, defina o correspondente em dst como branco}\par
1358 \par
1359             dst->data[pos] = src1->data[pos] - src2->data[pos];\par
1360 \par
1361             {\cf19 if} (dst->data[pos] > 255)\par
1362             \{\par
1363                 dst->data[pos] = 255;\par
1364             \}\par
1365 \par
1366             {\cf19 if} (dst->data[pos] < 0)\par
1367             \{\par
1368                 dst->data[pos] = 0;\par
1369             \}\par
1370         \}\par
1371     \}\par
1372 \}\par
}
}
{\xe \v comparePixelsAtPosition\:vc.h}
{\xe \v vc.h\:comparePixelsAtPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int comparePixelsAtPosition ({\b IVC} *  {\i src1}, {\b IVC} *  {\i src2}, int  {\i yc}, int  {\i width})}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2476 \{\par
2477     {\cf18 unsigned} {\cf18 char} *data1 = ({\cf18 unsigned} {\cf18 char} *)src1->data;\par
2478     {\cf18 unsigned} {\cf18 char} *data2 = ({\cf18 unsigned} {\cf18 char} *)src2->data;\par
2479     {\cf18 int} bytesperline = src1->bytesperline;\par
2480     {\cf18 int} channels = src1->channels;\par
2481 \par
2482     {\cf18 long} {\cf18 int} pos = yc * bytesperline + width * channels;\par
2483 \par
2484     {\cf19 if} (data1[pos] == data2[pos])\par
2485     \{\par
2486         {\cf19 return} 1;\par
2487     \}\par
2488     {\cf19 return} 0;\par
2489 \}\par
}
}
{\xe \v lookForWhite\:vc.h}
{\xe \v vc.h\:lookForWhite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lookForWhite ({\b IVC} *  {\i src}, int  {\i yc}, int *  {\i widths})}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2420 \{\par
2421     {\cf18 unsigned} {\cf18 char} *data = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
2422     {\cf18 int} width = src->width;\par
2423     {\cf18 int} bytesperline = src->bytesperline;\par
2424     {\cf18 int} channels = src->channels;\par
2425     {\cf18 int} x;\par
2426     {\cf18 long} {\cf18 int} pos;\par
2427 \par
2428     if ((src->width <= 0) || (src->height <= 0) || (src->data == NULL))\par
2429         {\cf19 return};\par
2430 \par
2431     {\cf19 if} (yc < 0 || yc >= src->height) {\cf20 // Ensure yc is within bounds}\par
2432         {\cf19 return};\par
2433 \par
2434     {\cf18 int} state = 0; {\cf20 // 0: looking for first white, 1: looking for transition to black, 2: looking for next white after black}\par
2435     {\cf18 int} count = 0;\par
2436 \par
2437     {\cf19 for} (x = 0; x < width; x++)\par
2438     \{\par
2439         pos = yc * bytesperline + x * channels;\par
2440 \par
2441         {\cf19 if} (state == 0)\par
2442         \{\par
2443             {\cf19 if} (data[pos] == 255)\par
2444             \{\par
2445                 {\cf19 if} (count < 3)\par
2446                 \{\par
2447                     widths[count++] = x + 4;\par
2448                 \}\par
2449 \par
2450                 state = 1;\par
2451             \}\par
2452         \}\par
2453         {\cf19 else} {\cf19 if} (state == 1)\par
2454         \{\par
2455             {\cf19 if} (data[pos] == 0)\par
2456             \{\par
2457                 state = 2;\par
2458             \}\par
2459         \}\par
2460         {\cf19 else} {\cf19 if} (state == 2)\par
2461         \{\par
2462             {\cf19 if} (data[pos] == 255)\par
2463             \{\par
2464                 {\cf19 if} (count < 3)\par
2465                 \{\par
2466                     widths[count++] = x + 4;\par
2467                 \}\par
2468 \par
2469                 state = 1;\par
2470             \}\par
2471         \}\par
2472     \}\par
2473 \}\par
}
}
{\xe \v vc_bgr_to_hsv\:vc.h}
{\xe \v vc.h\:vc_bgr_to_hsv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_bgr_to_hsv ({\b IVC} *  {\i srcdst})}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2097 \{\par
2098     {\cf18 unsigned} {\cf18 char} *data = ({\cf18 unsigned} {\cf18 char} *)srcdst->data;\par
2099     {\cf18 int} width = srcdst->width;\par
2100     {\cf18 int} height = srcdst->height;\par
2101     {\cf18 int} bytesperline = srcdst->bytesperline;\par
2102     {\cf18 int} channels = srcdst->channels;\par
2103     {\cf18 float} r, g, b, saturation, hue, value;\par
2104     {\cf18 int} i, size;\par
2105     {\cf18 int} pos_src;\par
2106     {\cf18 float} rgb_max;\par
2107     {\cf18 float} rgb_min;\par
2108 \par
2109     if ((srcdst->width <= 0) || (srcdst->height <= 0) || (srcdst->data == NULL))\par
2110         {\cf19 return} 0;\par
2111     {\cf19 if} (channels != 3)\par
2112         {\cf19 return} 0;\par
2113 \par
2114     size = width * height * channels;\par
2115 \par
2116     {\cf19 for} (i = 0; i < size; i += channels)\par
2117     \{\par
2118         pos_src = i;\par
2119 \par
2120         b = (float)data[pos_src];\par
2121         g = (float)data[pos_src + 1];\par
2122         r = (float)data[pos_src + 2];\par
2123 \par
2124         rgb_max = fmaxf(r, fmaxf(g, b));\par
2125         rgb_min = fminf(r, fminf(g, b));\par
2126 \par
2127         value = rgb_max;\par
2128 \par
2129         {\cf19 if} (value == 0.0f)\par
2130         \{\par
2131             hue = 0.0f;\par
2132             saturation = 0.0f;\par
2133         \}\par
2134         {\cf19 else}\par
2135         \{\par
2136             saturation = ((rgb_max - rgb_min) / rgb_max) * 255.0f;\par
2137 \par
2138             {\cf19 if} (saturation == 0.0f)\par
2139             \{\par
2140                 hue = 0.0f;\par
2141             \}\par
2142             {\cf19 else}\par
2143             \{\par
2144                 {\cf19 if} ((rgb_max == r) && (g >= b))\par
2145                 \{\par
2146                     hue = 60.0f * (g - b) / (rgb_max - rgb_min);\par
2147                 \}\par
2148                 {\cf19 else} {\cf19 if} ((rgb_max == r) && (b > g))\par
2149                 \{\par
2150                     hue = 360.0f + 60.0f * (g - b) / (rgb_max - rgb_min);\par
2151                 \}\par
2152                 {\cf19 else} {\cf19 if} (rgb_max == g)\par
2153                 \{\par
2154                     hue = 120.0f + 60.0f * (b - r) / (rgb_max - rgb_min);\par
2155                 \}\par
2156                 {\cf19 else} {\cf19 if} (rgb_max == b)\par
2157                 \{\par
2158                     hue = 240.0f + 60.0f * (r - g) / (rgb_max - rgb_min);\par
2159                 \}\par
2160             \}\par
2161         \}\par
2162 \par
2163         data[i] = ({\cf18 unsigned} char)(hue / 360.0f * 255.0f);\par
2164         data[i + 1] = ({\cf18 unsigned} char)(saturation);\par
2165         data[i + 2] = ({\cf18 unsigned} char)(value);\par
2166     \}\par
2167 \par
2168     {\cf19 return} 1;\par
2169 \}\par
}
}
{\xe \v vc_bgr_to_hsv2\:vc.h}
{\xe \v vc.h\:vc_bgr_to_hsv2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_bgr_to_hsv2 ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst})}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2492 \{\par
2493     {\cf18 unsigned} {\cf18 char} *data_src = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
2494     {\cf18 unsigned} {\cf18 char} *data_dst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
2495     {\cf18 int} width = src->width;\par
2496     {\cf18 int} height = src->height;\par
2497     {\cf18 int} bytesperline = src->bytesperline;\par
2498     {\cf18 int} channels = src->channels;\par
2499     {\cf18 float} r, g, b, saturation, hue, value;\par
2500     {\cf18 int} i, size;\par
2501     {\cf18 int} pos_src, pos_dst;\par
2502     {\cf18 float} rgb_max;\par
2503     {\cf18 float} rgb_min;\par
2504 \par
2505     {\cf19 if} ((src->width <= 0) || (src->height <= 0) || (src->data == NULL))\par
2506         {\cf19 return} 0;\par
2507     {\cf19 if} (channels != 3 || dst->channels != 3)\par
2508         {\cf19 return} 0;\par
2509 \par
2510     size = width * height * channels;\par
2511 \par
2512     {\cf19 for} (i = 0; i < size; i += channels)\par
2513     \{\par
2514         pos_src = i;\par
2515         pos_dst = i;\par
2516 \par
2517         b = (float)data_src[pos_src];\par
2518         g = (float)data_src[pos_src + 1];\par
2519         r = (float)data_src[pos_src + 2];\par
2520 \par
2521         rgb_max = fmaxf(r, fmaxf(g, b));\par
2522         rgb_min = fminf(r, fminf(g, b));\par
2523 \par
2524         value = rgb_max;\par
2525 \par
2526         {\cf19 if} (value == 0.0f)\par
2527         \{\par
2528             hue = 0.0f;\par
2529             saturation = 0.0f;\par
2530         \}\par
2531         {\cf19 else}\par
2532         \{\par
2533             saturation = ((rgb_max - rgb_min) / rgb_max) * 255.0f;\par
2534 \par
2535             {\cf19 if} (saturation == 0.0f)\par
2536             \{\par
2537                 hue = 0.0f;\par
2538             \}\par
2539             {\cf19 else}\par
2540             \{\par
2541                 {\cf19 if} ((rgb_max == r) && (g >= b))\par
2542                 \{\par
2543                     hue = 60.0f * (g - b) / (rgb_max - rgb_min);\par
2544                 \}\par
2545                 {\cf19 else} {\cf19 if} ((rgb_max == r) && (b > g))\par
2546                 \{\par
2547                     hue = 360.0f + 60.0f * (g - b) / (rgb_max - rgb_min);\par
2548                 \}\par
2549                 {\cf19 else} {\cf19 if} (rgb_max == g)\par
2550                 \{\par
2551                     hue = 120.0f + 60.0f * (b - r) / (rgb_max - rgb_min);\par
2552                 \}\par
2553                 {\cf19 else} {\cf19 if} (rgb_max == b)\par
2554                 \{\par
2555                     hue = 240.0f + 60.0f * (r - g) / (rgb_max - rgb_min);\par
2556                 \}\par
2557             \}\par
2558         \}\par
2559 \par
2560         data_dst[pos_dst] = ({\cf18 unsigned} char)(hue / 360.0f * 255.0f);\par
2561         data_dst[pos_dst + 1] = ({\cf18 unsigned} char)(saturation);\par
2562         data_dst[pos_dst + 2] = ({\cf18 unsigned} char)(value);\par
2563     \}\par
2564 \par
2565     {\cf19 return} 1;\par
2566 \}\par
}
}
{\xe \v vc_bgr_to_rgb\:vc.h}
{\xe \v vc.h\:vc_bgr_to_rgb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_bgr_to_rgb ({\b IVC} *  {\i srcdst})}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2069 \{\par
2070     {\cf19 if} (srcdst == NULL)\par
2071         {\cf19 return} 0;\par
2072     {\cf19 if} (srcdst->channels != 3)\par
2073         {\cf19 return} 0;\par
2074 \par
2075     {\cf18 unsigned} {\cf18 char} temp;\par
2076     {\cf18 int} width = srcdst->width;\par
2077     {\cf18 int} height = srcdst->height;\par
2078     {\cf18 int} bytesperline = srcdst->bytesperline;\par
2079     {\cf18 int} channels = srcdst->channels;\par
2080     {\cf18 unsigned} {\cf18 char} *data = srcdst->data;\par
2081 \par
2082     {\cf19 for} ({\cf18 int} y = 0; y < height; y++)\par
2083     \{\par
2084         {\cf19 for} ({\cf18 int} x = 0; x < width; x++)\par
2085         \{\par
2086             {\cf18 int} pos = y * bytesperline + x * channels;\par
2087 \par
2088             temp = data[pos];\par
2089             data[pos] = data[pos + 2];\par
2090             data[pos + 2] = temp;\par
2091         \}\par
2092     \}\par
2093     {\cf19 return} 1;\par
2094 \}\par
}
}
{\xe \v vc_binary_blob_info\:vc.h}
{\xe \v vc.h\:vc_binary_blob_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_binary_blob_info ({\b IVC} *  {\i src}, {\b OVC} *  {\i blobs}, int  {\i nblobs})}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1608 \{\par
1609     {\cf18 unsigned} {\cf18 char} *data = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
1610     {\cf18 int} width = src->width;\par
1611     {\cf18 int} height = src->height;\par
1612     {\cf18 int} bytesperline = src->bytesperline;\par
1613     {\cf18 int} channels = src->channels;\par
1614     {\cf18 int} x, y, i;\par
1615     {\cf18 long} {\cf18 int} pos;\par
1616     {\cf18 int} xmin, ymin, xmax, ymax;\par
1617     {\cf18 long} {\cf18 int} sumx, sumy;\par
1618 \par
1619     {\cf20 // Verifica\'EF\'BF\'BD\'EF\'BF\'BDo de erros}\par
1620     if ((src->width <= 0) || (src->height <= 0) || (src->data == NULL))\par
1621         {\cf19 return} 0;\par
1622     {\cf19 if} (channels != 1)\par
1623         {\cf19 return} 0;\par
1624 \par
1625     {\cf20 // Conta \'EF\'BF\'BDrea de cada blob}\par
1626     {\cf19 for} (i = 0; i < nblobs; i++)\par
1627     \{\par
1628         xmin = width - 1;\par
1629         ymin = height - 1;\par
1630         xmax = 0;\par
1631         ymax = 0;\par
1632 \par
1633         sumx = 0;\par
1634         sumy = 0;\par
1635 \par
1636         blobs[i].area = 0;\par
1637 \par
1638         {\cf19 for} (y = 1; y < height - 1; y++)\par
1639         \{\par
1640             {\cf19 for} (x = 1; x < width - 1; x++)\par
1641             \{\par
1642                 pos = y * bytesperline + x * channels;\par
1643 \par
1644                 {\cf19 if} (data[pos] == blobs[i].label)\par
1645                 \{\par
1646                     {\cf20 // \'EF\'BF\'BDrea}\par
1647                     blobs[i].area++;\par
1648 \par
1649                     {\cf20 // Centro de Gravidade}\par
1650                     sumx += x;\par
1651                     sumy += y;\par
1652 \par
1653                     {\cf20 // Bounding Box}\par
1654                     {\cf19 if} (xmin > x)\par
1655                         xmin = x;\par
1656                     {\cf19 if} (ymin > y)\par
1657                         ymin = y;\par
1658                     {\cf19 if} (xmax < x)\par
1659                         xmax = x;\par
1660                     {\cf19 if} (ymax < y)\par
1661                         ymax = y;\par
1662 \par
1663                     {\cf20 // Per\'EF\'BF\'BDmetro}\par
1664                     {\cf20 // Se pelo menos um dos quatro vizinhos n\'EF\'BF\'BDo pertence ao mesmo label, ent\'EF\'BF\'BDo \'EF\'BF\'BD um pixel de contorno}\par
1665                     {\cf19 if} ((data[pos - 1] != blobs[i].label) || (data[pos + 1] != blobs[i].label) || (data[pos - bytesperline] != blobs[i].label) || (data[pos + bytesperline] != blobs[i].label))\par
1666                     \{\par
1667                         blobs[i].perimeter++;\par
1668                     \}\par
1669                 \}\par
1670             \}\par
1671         \}\par
1672 \par
1673         {\cf20 // Bounding Box}\par
1674         blobs[i].x = xmin;\par
1675         blobs[i].y = ymin;\par
1676         blobs[i].width = (xmax - xmin) + 1;\par
1677         blobs[i].height = (ymax - ymin) + 1;\par
1678 \par
1679         {\cf20 // Centro de Gravidade}\par
1680         {\cf20 // blobs[i].xc = (xmax - xmin) / 2;}\par
1681         {\cf20 // blobs[i].yc = (ymax - ymin) / 2;}\par
1682         blobs[i].xc = sumx / MY_MAX(blobs[i].area, 1);\par
1683         blobs[i].yc = sumy / MY_MAX(blobs[i].area, 1);\par
1684     \}\par
1685 \par
1686     {\cf19 return} 1;\par
1687 \}\par
}
}
{\xe \v vc_binary_blob_labelling\:vc.h}
{\xe \v vc.h\:vc_binary_blob_labelling}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b OVC} * vc_binary_blob_labelling ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst}, int *  {\i nlabels})}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1401 \{\par
1402     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
1403     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
1404     {\cf18 int} width = src->width;\par
1405     {\cf18 int} height = src->height;\par
1406     {\cf18 int} bytesperline = src->bytesperline;\par
1407     {\cf18 int} channels = src->channels;\par
1408     {\cf18 int} x, y, a, b;\par
1409     {\cf18 long} {\cf18 int} i, size;\par
1410     {\cf18 long} {\cf18 int} posX, posA, posB, posC, posD;\par
1411     {\cf18 int} labeltable[256] = \{0\};\par
1412     {\cf18 int} labelarea[256] = \{0\};\par
1413     {\cf18 int} label = 1; {\cf20 // Etiqueta inicial.}\par
1414     {\cf18 int} num, tmplabel;\par
1415     OVC *blobs; {\cf20 // Apontador para array de blobs (objectos) que ser\'EF\'BF\'BD retornado desta fun\'EF\'BF\'BD\'EF\'BF\'BDo.}\par
1416 \par
1417     {\cf20 // Verifica\'EF\'BF\'BD\'EF\'BF\'BDo de erros}\par
1418     {\cf19 if} ((src->width <= 0) || (src->height <= 0) || (src->data == NULL))\par
1419         {\cf19 return} 0;\par
1420     {\cf19 if} ((src->width != dst->width) || (src->height != dst->height) || (src->channels != dst->channels))\par
1421         {\cf19 return} NULL;\par
1422     {\cf19 if} (channels != 1)\par
1423         {\cf19 return} NULL;\par
1424 \par
1425     {\cf20 // Copia dados da imagem bin\'EF\'BF\'BDria para imagem grayscale}\par
1426     memcpy(datadst, datasrc, bytesperline * height);\par
1427 \par
1428     {\cf20 // Todos os pix\'EF\'BF\'BDis de plano de fundo devem obrigat\'EF\'BF\'BDriamente ter valor 0}\par
1429     {\cf20 // Todos os pix\'EF\'BF\'BDis de primeiro plano devem obrigat\'EF\'BF\'BDriamente ter valor 255}\par
1430     {\cf20 // Ser\'EF\'BF\'BDo atribu\'EF\'BF\'BDdas etiquetas no intervalo [1,254]}\par
1431     {\cf20 // Este algoritmo est\'EF\'BF\'BD assim limitado a 254 labels}\par
1432     {\cf19 for} (i = 0, size = bytesperline * height; i < size; i++)\par
1433     \{\par
1434         {\cf19 if} (datadst[i] != 0)\par
1435             datadst[i] = 255;\par
1436     \}\par
1437 \par
1438     {\cf20 // Limpa os rebordos da imagem bin\'EF\'BF\'BDria}\par
1439     {\cf19 for} (y = 0; y < height; y++)\par
1440     \{\par
1441         datadst[y * bytesperline + 0 * channels] = 0;\par
1442         datadst[y * bytesperline + (width - 1) * channels] = 0;\par
1443     \}\par
1444     {\cf19 for} (x = 0; x < width; x++)\par
1445     \{\par
1446         datadst[0 * bytesperline + x * channels] = 0;\par
1447         datadst[(height - 1) * bytesperline + x * channels] = 0;\par
1448     \}\par
1449 \par
1450     {\cf20 // Efectua a etiquetagem}\par
1451     {\cf19 for} (y = 1; y < height - 1; y++)\par
1452     \{\par
1453         {\cf19 for} (x = 1; x < width - 1; x++)\par
1454         \{\par
1455             {\cf20 // Kernel:}\par
1456             {\cf20 // A B C}\par
1457             {\cf20 // D X}\par
1458 \par
1459             posA = (y - 1) * bytesperline + (x - 1) * channels; {\cf20 // A}\par
1460             posB = (y - 1) * bytesperline + x * channels;       {\cf20 // B}\par
1461             posC = (y - 1) * bytesperline + (x + 1) * channels; {\cf20 // C}\par
1462             posD = y * bytesperline + (x - 1) * channels;       {\cf20 // D}\par
1463             posX = y * bytesperline + x * channels;             {\cf20 // X}\par
1464 \par
1465             {\cf20 // Se o pixel foi marcado}\par
1466             {\cf19 if} (datadst[posX] != 0)\par
1467             \{\par
1468                 {\cf19 if} ((datadst[posA] == 0) && (datadst[posB] == 0) && (datadst[posC] == 0) && (datadst[posD] == 0))\par
1469                 \{\par
1470                     datadst[posX] = label;\par
1471                     labeltable[label] = label;\par
1472                     label++;\par
1473                 \}\par
1474                 {\cf19 else}\par
1475                 \{\par
1476                     num = 255;\par
1477 \par
1478                     {\cf20 // Se A est\'EF\'BF\'BD marcado}\par
1479                     {\cf19 if} (datadst[posA] != 0)\par
1480                         num = labeltable[datadst[posA]];\par
1481                     {\cf20 // Se B est\'EF\'BF\'BD marcado, e \'EF\'BF\'BD menor que a etiqueta "num"}\par
1482                     {\cf19 if} ((datadst[posB] != 0) && (labeltable[datadst[posB]] < num))\par
1483                         num = labeltable[datadst[posB]];\par
1484                     {\cf20 // Se C est\'EF\'BF\'BD marcado, e \'EF\'BF\'BD menor que a etiqueta "num"}\par
1485                     {\cf19 if} ((datadst[posC] != 0) && (labeltable[datadst[posC]] < num))\par
1486                         num = labeltable[datadst[posC]];\par
1487                     {\cf20 // Se D est\'EF\'BF\'BD marcado, e \'EF\'BF\'BD menor que a etiqueta "num"}\par
1488                     {\cf19 if} ((datadst[posD] != 0) && (labeltable[datadst[posD]] < num))\par
1489                         num = labeltable[datadst[posD]];\par
1490 \par
1491                     {\cf20 // Atribui a etiqueta ao pixel}\par
1492                     datadst[posX] = num;\par
1493                     labeltable[num] = num;\par
1494 \par
1495                     {\cf20 // Actualiza a tabela de etiquetas}\par
1496                     {\cf19 if} (datadst[posA] != 0)\par
1497                     \{\par
1498                         {\cf19 if} (labeltable[datadst[posA]] != num)\par
1499                         \{\par
1500                             {\cf19 for} (tmplabel = labeltable[datadst[posA]], a = 1; a < label; a++)\par
1501                             \{\par
1502                                 {\cf19 if} (labeltable[a] == tmplabel)\par
1503                                 \{\par
1504                                     labeltable[a] = num;\par
1505                                 \}\par
1506                             \}\par
1507                         \}\par
1508                     \}\par
1509                     {\cf19 if} (datadst[posB] != 0)\par
1510                     \{\par
1511                         {\cf19 if} (labeltable[datadst[posB]] != num)\par
1512                         \{\par
1513                             {\cf19 for} (tmplabel = labeltable[datadst[posB]], a = 1; a < label; a++)\par
1514                             \{\par
1515                                 {\cf19 if} (labeltable[a] == tmplabel)\par
1516                                 \{\par
1517                                     labeltable[a] = num;\par
1518                                 \}\par
1519                             \}\par
1520                         \}\par
1521                     \}\par
1522                     {\cf19 if} (datadst[posC] != 0)\par
1523                     \{\par
1524                         {\cf19 if} (labeltable[datadst[posC]] != num)\par
1525                         \{\par
1526                             {\cf19 for} (tmplabel = labeltable[datadst[posC]], a = 1; a < label; a++)\par
1527                             \{\par
1528                                 {\cf19 if} (labeltable[a] == tmplabel)\par
1529                                 \{\par
1530                                     labeltable[a] = num;\par
1531                                 \}\par
1532                             \}\par
1533                         \}\par
1534                     \}\par
1535                     {\cf19 if} (datadst[posD] != 0)\par
1536                     \{\par
1537                         {\cf19 if} (labeltable[datadst[posD]] != num)\par
1538                         \{\par
1539                             {\cf19 for} (tmplabel = labeltable[datadst[posD]], a = 1; a < label; a++)\par
1540                             \{\par
1541                                 {\cf19 if} (labeltable[a] == tmplabel)\par
1542                                 \{\par
1543                                     labeltable[a] = num;\par
1544                                 \}\par
1545                             \}\par
1546                         \}\par
1547                     \}\par
1548                 \}\par
1549             \}\par
1550         \}\par
1551     \}\par
1552 \par
1553     {\cf20 // Volta a etiquetar a imagem}\par
1554     {\cf19 for} (y = 1; y < height - 1; y++)\par
1555     \{\par
1556         {\cf19 for} (x = 1; x < width - 1; x++)\par
1557         \{\par
1558             posX = y * bytesperline + x * channels; {\cf20 // X}\par
1559 \par
1560             {\cf19 if} (datadst[posX] != 0)\par
1561             \{\par
1562                 datadst[posX] = labeltable[datadst[posX]];\par
1563             \}\par
1564         \}\par
1565     \}\par
1566 \par
1567     {\cf20 // printf("\\nMax Label = %d\\n", label);}\par
1568 \par
1569     {\cf20 // Contagem do n\'EF\'BF\'BDmero de blobs}\par
1570     {\cf20 // Passo 1: Eliminar, da tabela, etiquetas repetidas}\par
1571     {\cf19 for} (a = 1; a < label - 1; a++)\par
1572     \{\par
1573         {\cf19 for} (b = a + 1; b < label; b++)\par
1574         \{\par
1575             {\cf19 if} (labeltable[a] == labeltable[b])\par
1576                 labeltable[b] = 0;\par
1577         \}\par
1578     \}\par
1579     {\cf20 // Passo 2: Conta etiquetas e organiza a tabela de etiquetas, para que n\'EF\'BF\'BDo hajam valores vazios (zero) entre etiquetas}\par
1580     *nlabels = 0;\par
1581     {\cf19 for} (a = 1; a < label; a++)\par
1582     \{\par
1583         {\cf19 if} (labeltable[a] != 0)\par
1584         \{\par
1585             labeltable[*nlabels] = labeltable[a]; {\cf20 // Organiza tabela de etiquetas}\par
1586             (*nlabels)++;                         {\cf20 // Conta etiquetas}\par
1587         \}\par
1588     \}\par
1589 \par
1590     {\cf20 // Se n\'EF\'BF\'BDo h\'EF\'BF\'BD blobs}\par
1591     {\cf19 if} (*nlabels == 0)\par
1592         {\cf19 return} NULL;\par
1593 \par
1594     {\cf20 // Cria lista de blobs (objectos) e preenche a etiqueta}\par
1595     blobs = (OVC *)calloc((*nlabels), {\cf17 sizeof}(OVC));\par
1596     {\cf19 if} (blobs != NULL)\par
1597     \{\par
1598         {\cf19 for} (a = 0; a < (*nlabels); a++)\par
1599             blobs[a].label = labeltable[a];\par
1600     \}\par
1601     {\cf19 else}\par
1602         {\cf19 return} NULL;\par
1603 \par
1604     {\cf19 return} blobs;\par
1605 \}\par
}
}
{\xe \v vc_binary_close\:vc.h}
{\xe \v vc.h\:vc_binary_close}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_binary_close ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst}, int  {\i kernel})}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1200 \{\par
1201     {\cf18 int} ret = 1;\par
1202     IVC *tmp = vc_image_new(src->width, src->height, src->channels, src->levels);\par
1203 \par
1204     ret &= vc_binary_dilate(src, tmp, kernel);\par
1205     ret &= vc_binary_erode(tmp, dst, kernel);\par
1206 \par
1207     vc_image_free(tmp);\par
1208 \par
1209     {\cf19 return} ret;\par
1210 \}\par
}
}
{\xe \v vc_binary_dilate\:vc.h}
{\xe \v vc.h\:vc_binary_dilate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_binary_dilate ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst}, int  {\i kernel})}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1080 \{\par
1081     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
1082     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
1083     {\cf18 int} width = src->width;\par
1084     {\cf18 int} height = src->height;\par
1085     {\cf18 int} bytesperline = src->bytesperline;\par
1086     {\cf18 int} channels = src->channels;\par
1087     {\cf18 int} offset = (kernel - 1) / 2;\par
1088     {\cf18 int} x, y, kx, ky;\par
1089     {\cf18 int} soma;\par
1090     {\cf18 long} {\cf18 int} pos, posk;\par
1091     {\cf18 unsigned} {\cf18 char} threshold;\par
1092 \par
1093     {\cf20 // Check for valid conditions}\par
1094     {\cf19 if} ((src->width <= 0) || (src->height <= 0) || (src->data == NULL))\par
1095         {\cf19 return} 0;\par
1096     {\cf19 if} ((src->width != dst->width) || (src->height != dst->height) || (src->channels != dst->channels))\par
1097         {\cf19 return} 0;\par
1098     {\cf19 if} (channels != 1)\par
1099         {\cf19 return} 0;\par
1100 \par
1101     {\cf19 for} (y = 0; y < height; y++)\par
1102     \{\par
1103         {\cf19 for} (x = 0; x < width; x++)\par
1104         \{\par
1105             pos = y * bytesperline + x * channels;\par
1106 \par
1107             soma = 0;\par
1108             {\cf19 for} (ky = -offset; ky <= offset; ky++)\par
1109             \{\par
1110 \par
1111                 {\cf19 for} (kx = -offset; kx <= offset; kx++)\par
1112                 \{\par
1113                     {\cf19 if} ((y + ky >= 0) && (y + ky < height) && (x + kx >= 0) && (x + kx < width))\par
1114                     \{\par
1115                         posk = (y + ky) * bytesperline + (x + kx) * channels;\par
1116 \par
1117                         soma += datasrc[posk];\par
1118                     \}\par
1119                 \}\par
1120             \}\par
1121 \par
1122             {\cf19 if} (soma >= 1)\par
1123                 datadst[pos] = 255;\par
1124             {\cf19 else}\par
1125                 datadst[pos] = 0;\par
1126         \}\par
1127     \}\par
1128     {\cf19 return} 1;\par
1129 \}\par
}
}
{\xe \v vc_binary_erode\:vc.h}
{\xe \v vc.h\:vc_binary_erode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_binary_erode ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst}, int  {\i kernel})}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1132 \{\par
1133     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
1134     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
1135     {\cf18 int} width = src->width;\par
1136     {\cf18 int} height = src->height;\par
1137     {\cf18 int} bytesperline = src->bytesperline;\par
1138     {\cf18 int} channels = src->channels;\par
1139     {\cf18 int} offset = (kernel - 1) / 2;\par
1140     {\cf18 int} x, y, kx, ky;\par
1141     {\cf18 int} ww;\par
1142     {\cf18 long} {\cf18 int} pos, posk;\par
1143     {\cf18 unsigned} {\cf18 char} threshold;\par
1144 \par
1145     {\cf20 // Check for valid conditions}\par
1146     {\cf19 if} ((src->width <= 0) || (src->height <= 0) || (src->data == NULL))\par
1147         {\cf19 return} 0;\par
1148     {\cf19 if} ((src->width != dst->width) || (src->height != dst->height) || (src->channels != dst->channels))\par
1149         {\cf19 return} 0;\par
1150     {\cf19 if} (channels != 1)\par
1151         {\cf19 return} 0;\par
1152 \par
1153     {\cf19 for} (y = 0; y < height; y++)\par
1154     \{\par
1155         {\cf19 for} (x = 0; x < width; x++)\par
1156         \{\par
1157             pos = y * bytesperline + x * channels;\par
1158 \par
1159             ww = 0;\par
1160             {\cf19 for} (ky = -offset; ky <= offset; ky++)\par
1161             \{\par
1162 \par
1163                 {\cf19 for} (kx = -offset; kx <= offset; kx++)\par
1164                 \{\par
1165                     {\cf19 if} ((y + ky >= 0) && (y + ky < height) && (x + kx >= 0) && (x + kx < width))\par
1166                     \{\par
1167                         posk = (y + ky) * bytesperline + (x + kx) * channels;\par
1168 \par
1169                         {\cf19 if} (datasrc[posk] == 0)\par
1170                         \{\par
1171                             ww = 1;\par
1172                         \}\par
1173                     \}\par
1174                 \}\par
1175             \}\par
1176 \par
1177             {\cf19 if} (ww == 1)\par
1178                 datadst[pos] = 0;\par
1179             {\cf19 else}\par
1180                 datadst[pos] = 255;\par
1181         \}\par
1182     \}\par
1183     {\cf19 return} 1;\par
1184 \}\par
}
}
{\xe \v vc_binary_open\:vc.h}
{\xe \v vc.h\:vc_binary_open}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_binary_open ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst}, int  {\i kernel})}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1187 \{\par
1188     {\cf18 int} ret = 1;\par
1189     IVC *tmp = vc_image_new(src->width, src->height, src->channels, src->levels);\par
1190 \par
1191     ret &= vc_binary_erode(src, tmp, kernel);\par
1192     ret &= vc_binary_dilate(tmp, dst, kernel);\par
1193 \par
1194     vc_image_free(tmp);\par
1195 \par
1196     {\cf19 return} ret;\par
1197 \}\par
}
}
{\xe \v vc_coloring\:vc.h}
{\xe \v vc.h\:vc_coloring}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_coloring ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst}, int  {\i nlabels})}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1690 \{\par
1691     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
1692     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
1693     {\cf18 int} width = src->width;\par
1694     {\cf18 int} height = src->height;\par
1695     {\cf18 int} bytesperline_src = src->bytesperline;\par
1696     {\cf18 int} bytesperline_dst = dst->bytesperline;\par
1697     {\cf18 int} channels_src = src->channels;\par
1698     {\cf18 int} channels_dst = dst->channels;\par
1699     {\cf18 int} x, y;\par
1700 \par
1701     {\cf20 // Define gray range and compute increment}\par
1702     {\cf18 int} min_gray = 50;\par
1703     {\cf18 int} max_gray = 255;\par
1704     {\cf18 float} gray_increment = (nlabels > 1) ? (max_gray - min_gray) / (float)(nlabels - 1) : 0;\par
1705 \par
1706     {\cf19 for} (y = 0; y < height; y++)\par
1707     \{\par
1708         {\cf19 for} (x = 0; x < width; x++)\par
1709         \{\par
1710             {\cf18 long} {\cf18 int} pos = y * bytesperline_src + x * channels_src;\par
1711             {\cf18 unsigned} {\cf18 char} label = datasrc[pos];\par
1712 \par
1713             {\cf19 if} (label == 0)\par
1714             \{\par
1715                 datadst[pos] = 0; {\cf20 // Background remains black}\par
1716             \}\par
1717             {\cf19 else} {\cf19 if} (label > 0 && label <= nlabels)\par
1718             \{\par
1719                 {\cf18 float} gray_shade = min_gray + (label - 1) * gray_increment;\par
1720                 datadst[pos] = ({\cf18 unsigned} char)(gray_shade + 0.5f); {\cf20 // Rounding to nearest integer}\par
1721             \}\par
1722         \}\par
1723     \}\par
1724 \par
1725     {\cf19 return} 1;\par
1726 \}\par
}
}
{\xe \v vc_draw_boundingbox\:vc.h}
{\xe \v vc.h\:vc_draw_boundingbox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_draw_boundingbox ({\b IVC} *  {\i srcdst}, {\b OVC} *  {\i blobs}, int  {\i nblobs})}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1729 \{\par
1730     {\cf18 unsigned} {\cf18 char} *data = srcdst->data;\par
1731     {\cf18 int} width = srcdst->width;\par
1732     {\cf18 int} height = srcdst->height;\par
1733     {\cf18 int} bytesperline = srcdst->bytesperline;\par
1734     {\cf18 int} channels = srcdst->channels;\par
1735     {\cf18 int} x, y, i;\par
1736 \par
1737     {\cf20 // Verify the validity of input parameters}\par
1738     {\cf19 if} (!data || width <= 0 || height <= 0 || channels < 1)\par
1739         {\cf19 return} 0;\par
1740 \par
1741     {\cf20 // Process each blob}\par
1742     {\cf19 for} (i = 0; i < nblobs; i++)\par
1743     \{\par
1744         {\cf18 int} xmin = blobs[i].x;\par
1745         {\cf18 int} ymin = blobs[i].y;\par
1746         {\cf18 int} xmax = xmin + blobs[i].width;\par
1747         {\cf18 int} ymax = ymin + blobs[i].height;\par
1748 \par
1749         {\cf20 // Ensure the bounding box is within the image boundaries}\par
1750         xmin = MY_MAX(0, xmin);\par
1751         ymin = MY_MAX(0, ymin);\par
1752         xmax = MY_MIN(width - 1, xmax);\par
1753         ymax = MY_MIN(height - 1, ymax);\par
1754 \par
1755         {\cf20 // Draw horizontal lines at the top and bottom of the bounding box}\par
1756         {\cf19 for} (x = xmin; x <= xmax; x++)\par
1757         \{\par
1758             {\cf18 int} topPos = ymin * bytesperline + x * channels;\par
1759             {\cf18 int} bottomPos = ymax * bytesperline + x * channels;\par
1760             {\cf19 for} ({\cf18 int} channel = 0; channel < channels; channel++)\par
1761             \{\par
1762                 data[topPos + channel] = 255;    {\cf20 // Set to white}\par
1763                 data[bottomPos + channel] = 255; {\cf20 // Set to white}\par
1764             \}\par
1765         \}\par
1766 \par
1767         {\cf20 // Draw vertical lines on the left and right of the bounding box}\par
1768         {\cf19 for} (y = ymin; y <= ymax; y++)\par
1769         \{\par
1770             {\cf18 int} leftPos = y * bytesperline + xmin * channels;\par
1771             {\cf18 int} rightPos = y * bytesperline + xmax * channels;\par
1772             {\cf19 for} ({\cf18 int} channel = 0; channel < channels; channel++)\par
1773             \{\par
1774                 data[leftPos + channel] = 255;  {\cf20 // Set to white}\par
1775                 data[rightPos + channel] = 255; {\cf20 // Set to white}\par
1776             \}\par
1777         \}\par
1778     \}\par
1779 \par
1780     {\cf19 return} 1;\par
1781 \}\par
}
}
{\xe \v vc_draw_centerofgravity\:vc.h}
{\xe \v vc.h\:vc_draw_centerofgravity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_draw_centerofgravity ({\b IVC} *  {\i srcdst}, {\b OVC} *  {\i blobs}, int  {\i nblobs}, int  {\i s})}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1784 \{\par
1785     {\cf18 unsigned} {\cf18 char} *data = srcdst->data;\par
1786     {\cf18 int} width = srcdst->width;\par
1787     {\cf18 int} height = srcdst->height;\par
1788     {\cf18 int} bytesperline = srcdst->bytesperline;\par
1789     {\cf18 int} channels = srcdst->channels;\par
1790     {\cf18 int} c, x, y;\par
1791     {\cf18 int} xmin, xmax, ymin, ymax;\par
1792 \par
1793     {\cf20 // Check for valid data and image dimensions}\par
1794     {\cf19 if} (!data || width <= 0 || height <= 0 || channels < 1)\par
1795         {\cf19 return} 0;\par
1796 \par
1797     {\cf19 for} (c = 0; c < nblobs; c++)\par
1798     \{\par
1799         {\cf18 int} xc = blobs[c].xc;\par
1800         {\cf18 int} yc = blobs[c].yc;\par
1801 \par
1802         ymin = yc - s;\par
1803         ymax = yc + s;\par
1804         xmin = xc - s;\par
1805         xmax = xc + s;\par
1806 \par
1807         {\cf20 // Draw vertical line of the cross}\par
1808         {\cf19 for} (y = MY_MAX(0, ymin); y <= MY_MIN(ymax, height - 1); y++)\par
1809         \{\par
1810             {\cf18 int} pos = y * bytesperline + xc * channels;\par
1811             {\cf19 if} (xc >= 0 && xc < width)\par
1812             \{\par
1813                 {\cf19 for} ({\cf18 int} channel = 0; channel < channels; channel++)\par
1814                 \{\par
1815                     data[pos + channel] = 255; {\cf20 // Set to white}\par
1816                 \}\par
1817             \}\par
1818         \}\par
1819 \par
1820         {\cf20 // Draw horizontal line of the cross}\par
1821         {\cf19 for} (x = MY_MAX(0, xmin); x <= MY_MIN(xmax, width - 1); x++)\par
1822         \{\par
1823             {\cf18 int} pos = yc * bytesperline + x * channels;\par
1824             {\cf19 if} (yc >= 0 && yc < height)\par
1825             \{\par
1826                 {\cf19 for} ({\cf18 int} channel = 0; channel < channels; channel++)\par
1827                 \{\par
1828                     data[pos + channel] = 255; {\cf20 // Set to white}\par
1829                 \}\par
1830             \}\par
1831         \}\par
1832     \}\par
1833 \par
1834     {\cf19 return} 1;\par
1835 \}\par
}
}
{\xe \v vc_gray_close\:vc.h}
{\xe \v vc.h\:vc_gray_close}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_gray_close ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst}, int  {\i kernel})}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1331 \{\par
1332     {\cf18 int} ret = 1;\par
1333     IVC *tmp = vc_image_new(src->width, src->height, src->channels, src->levels);\par
1334 \par
1335     ret &= vc_gray_dilate(src, tmp, kernel);\par
1336     ret &= vc_gray_erode(tmp, dst, kernel);\par
1337 \par
1338     vc_image_free(tmp);\par
1339 \par
1340     {\cf19 return} ret;\par
1341 \}\par
}
}
{\xe \v vc_gray_dilate\:vc.h}
{\xe \v vc.h\:vc_gray_dilate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_gray_dilate ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst}, int  {\i kernel})}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1213 \{\par
1214     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
1215     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
1216     {\cf18 int} width = src->width;\par
1217     {\cf18 int} height = src->height;\par
1218     {\cf18 int} bytesperline = src->bytesperline;\par
1219     {\cf18 int} channels = src->channels;\par
1220     {\cf18 int} offset = (kernel - 1) / 2;\par
1221     {\cf18 int} x, y, kx, ky;\par
1222     {\cf18 int} soma, max, w;\par
1223     {\cf18 long} {\cf18 int} pos, posk;\par
1224     {\cf18 unsigned} {\cf18 char} threshold;\par
1225 \par
1226     {\cf20 // Check for valid conditions}\par
1227     {\cf19 if} ((src->width <= 0) || (src->height <= 0) || (src->data == NULL))\par
1228         {\cf19 return} 0;\par
1229     {\cf19 if} ((src->width != dst->width) || (src->height != dst->height) || (src->channels != dst->channels))\par
1230         {\cf19 return} 0;\par
1231     {\cf19 if} (channels != 1)\par
1232         {\cf19 return} 0;\par
1233 \par
1234     {\cf19 for} (y = 0; y < height; y++)\par
1235     \{\par
1236         {\cf19 for} (x = 0; x < width; x++)\par
1237         \{\par
1238             pos = y * bytesperline + x * channels;\par
1239 \par
1240             max = 0;\par
1241 \par
1242             {\cf19 for} (ky = -offset; ky <= offset; ky++)\par
1243             \{\par
1244 \par
1245                 {\cf19 for} (kx = -offset; kx <= offset; kx++)\par
1246                 \{\par
1247                     {\cf19 if} ((y + ky >= 0) && (y + ky < height) && (x + kx >= 0) && (x + kx < width))\par
1248                     \{\par
1249                         posk = (y + ky) * bytesperline + (x + kx) * channels;\par
1250 \par
1251                         {\cf19 if} (max < datasrc[posk])\par
1252                         \{\par
1253                             max = datasrc[posk];\par
1254                         \}\par
1255                     \}\par
1256                 \}\par
1257             \}\par
1258 \par
1259             datadst[pos] = max;\par
1260         \}\par
1261     \}\par
1262     {\cf19 return} 1;\par
1263 \}\par
}
}
{\xe \v vc_gray_edge_prewitt\:vc.h}
{\xe \v vc.h\:vc_gray_edge_prewitt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_gray_edge_prewitt ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst}, float  {\i th})}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1952 \{\par
1953     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
1954     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
1955     {\cf18 int} width = src->width;\par
1956     {\cf18 int} height = src->height;\par
1957     {\cf18 int} bytesperline = src->bytesperline;\par
1958     {\cf18 int} channels = src->channels;\par
1959     {\cf18 int} x, y;\par
1960     {\cf18 long} {\cf18 int} posX, posA, posB, posC, posD, posE, posF, posG, posH;\par
1961     {\cf18 int} i, size;\par
1962     {\cf18 float} histmax;\par
1963     {\cf18 int} histthreshold;\par
1964     {\cf18 int} sumx, sumy;\par
1965     {\cf18 float} hist[256] = \{0.0f\};\par
1966 \par
1967     {\cf20 // Verifica\'E7\'E3o de erros}\par
1968     {\cf19 if} ((src->width <= 0) || (src->height <= 0) || (src->data == NULL))\par
1969         {\cf19 return} 0;\par
1970     {\cf19 if} ((src->width != dst->width) || (src->height != dst->height) || (src->channels != dst->channels))\par
1971         {\cf19 return} 0;\par
1972     {\cf19 if} (channels != 1)\par
1973         {\cf19 return} 0;\par
1974 \par
1975     size = width * height;\par
1976 \par
1977     {\cf19 for} (y = 1; y < height - 1; y++)\par
1978     \{\par
1979         {\cf19 for} (x = 1; x < width - 1; x++)\par
1980         \{\par
1981             {\cf20 // PosA PosB PosC}\par
1982             {\cf20 // PosD PosX PosE}\par
1983             {\cf20 // PosF PosG PosH}\par
1984 \par
1985             posA = (y - 1) * bytesperline + (x - 1) * channels;\par
1986             posB = (y - 1) * bytesperline + x * channels;\par
1987             posC = (y - 1) * bytesperline + (x + 1) * channels;\par
1988             posD = y * bytesperline + (x - 1) * channels;\par
1989             posX = y * bytesperline + x * channels;\par
1990             posE = y * bytesperline + (x + 1) * channels;\par
1991             posF = (y + 1) * bytesperline + (x - 1) * channels;\par
1992             posG = (y + 1) * bytesperline + x * channels;\par
1993             posH = (y + 1) * bytesperline + (x + 1) * channels;\par
1994 \par
1995             {\cf20 // PosA*(-1) PosB*0 PosC*(1)}\par
1996             {\cf20 // PosD*(-1) PosX*0 PosE*(1)}\par
1997             {\cf20 // PosF*(-1) PosG*0 PosH*(1)}\par
1998 \par
1999             sumx = datasrc[posA] * -1;\par
2000             sumx += datasrc[posD] * -1;\par
2001             sumx += datasrc[posF] * -1;\par
2002 \par
2003             sumx += datasrc[posC] * +1;\par
2004             sumx += datasrc[posE] * +1;\par
2005             sumx += datasrc[posH] * +1;\par
2006             sumx = sumx / 3; {\cf20 // 3 = 1 + 1 + 1}\par
2007 \par
2008             {\cf20 // PosA*(-1) PosB*(-1) PosC*(-1)}\par
2009             {\cf20 // PosD*0    PosX*0    PosE*0}\par
2010             {\cf20 // PosF*(1)  PosG*(1)  PosH*(1)}\par
2011 \par
2012             sumy = datasrc[posA] * -1;\par
2013             sumy += datasrc[posB] * -1;\par
2014             sumy += datasrc[posC] * -1;\par
2015 \par
2016             sumy += datasrc[posF] * +1;\par
2017             sumy += datasrc[posG] * +1;\par
2018             sumy += datasrc[posH] * +1;\par
2019             sumy = sumy / 3; {\cf20 // 3 = 1 + 1 + 1}\par
2020 \par
2021             {\cf20 // datadst[posX] = (unsigned char)sqrt((double)(sumx*sumx + sumy*sumy));}\par
2022             datadst[posX] = ({\cf18 unsigned} char)(sqrt(({\cf18 double})(sumx * sumx + sumy * sumy)) / sqrt(2.0));\par
2023             {\cf20 // Explica\'E7\'E3o:}\par
2024             {\cf20 // Queremos que no caso do pior cen\'E1rio, em que sumx = sumy = 255, o resultado}\par
2025             {\cf20 // da opera\'E7\'E3o se mantenha no intervalo de valores admitido, isto \'E9, entre [0, 255].}\par
2026             {\cf20 // Se se considerar que:}\par
2027             {\cf20 // max = 255}\par
2028             {\cf20 // Ent\'E3o,}\par
2029             {\cf20 // sqrt(pow(max,2) + pow(max,2)) * k = max <=> sqrt(2*pow(max,2)) * k = max <=> k = max / (sqrt(2) * max) <=>}\par
2030             {\cf20 // k = 1 / sqrt(2)}\par
2031         \}\par
2032     \}\par
2033 \par
2034     {\cf20 // Calcular o histograma com o valor das magnitudes}\par
2035     {\cf19 for} (i = 0; i < size; i++)\par
2036     \{\par
2037         hist[datadst[i]]++;\par
2038     \}\par
2039 \par
2040     {\cf20 // Definir o threshold.}\par
2041     {\cf20 // O threshold \'E9 definido pelo n\'EDvel de intensidade (das magnitudes)}\par
2042     {\cf20 // quando se atinge uma determinada percentagem de pixeis, definida pelo utilizador.}\par
2043     {\cf20 // Por exemplo, se o par\'E2metro 'th' tiver valor 0.8, significa the o threshold ser\'E1 o}\par
2044     {\cf20 // n\'EDvel de magnitude, abaixo do qual est\'E3o pelo menos 80% dos pixeis.}\par
2045     histmax = 0.0f;\par
2046     {\cf19 for} (i = 0; i <= 255; i++)\par
2047     \{\par
2048         histmax += hist[i];\par
2049 \par
2050         {\cf20 // th = Prewitt Threshold}\par
2051         {\cf19 if} (histmax >= ((({\cf18 float})size) * th))\par
2052             {\cf19 break};\par
2053     \}\par
2054     histthreshold = i == 0 ? 1 : i;\par
2055 \par
2056     {\cf20 // Aplicada o threshold}\par
2057     {\cf19 for} (i = 0; i < size; i++)\par
2058     \{\par
2059         {\cf19 if} (datadst[i] >= ({\cf18 unsigned} {\cf18 char})histthreshold)\par
2060             datadst[i] = 255;\par
2061         {\cf19 else}\par
2062             datadst[i] = 0;\par
2063     \}\par
2064 \par
2065     {\cf19 return} 1;\par
2066 \}\par
}
}
{\xe \v vc_gray_erode\:vc.h}
{\xe \v vc.h\:vc_gray_erode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_gray_erode ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst}, int  {\i kernel})}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1266 \{\par
1267     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
1268     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
1269     {\cf18 int} width = src->width;\par
1270     {\cf18 int} height = src->height;\par
1271     {\cf18 int} bytesperline = src->bytesperline;\par
1272     {\cf18 int} channels = src->channels;\par
1273     {\cf18 int} offset = (kernel - 1) / 2;\par
1274     {\cf18 int} x, y, kx, ky;\par
1275     {\cf18 int} min;\par
1276     {\cf18 long} {\cf18 int} pos, posk;\par
1277     {\cf18 unsigned} {\cf18 char} threshold;\par
1278 \par
1279     {\cf20 // Check for valid conditions}\par
1280     {\cf19 if} ((src->width <= 0) || (src->height <= 0) || (src->data == NULL))\par
1281         {\cf19 return} 0;\par
1282     {\cf19 if} ((src->width != dst->width) || (src->height != dst->height) || (src->channels != dst->channels))\par
1283         {\cf19 return} 0;\par
1284     {\cf19 if} (channels != 1)\par
1285         {\cf19 return} 0;\par
1286 \par
1287     {\cf19 for} (y = 0; y < height; y++)\par
1288     \{\par
1289         {\cf19 for} (x = 0; x < width; x++)\par
1290         \{\par
1291             pos = y * bytesperline + x * channels;\par
1292 \par
1293             min = 255;\par
1294             {\cf19 for} (ky = -offset; ky <= offset; ky++)\par
1295             \{\par
1296 \par
1297                 {\cf19 for} (kx = -offset; kx <= offset; kx++)\par
1298                 \{\par
1299                     {\cf19 if} ((y + ky >= 0) && (y + ky < height) && (x + kx >= 0) && (x + kx < width))\par
1300                     \{\par
1301                         posk = (y + ky) * bytesperline + (x + kx) * channels;\par
1302 \par
1303                         {\cf19 if} (min > datasrc[posk])\par
1304                         \{\par
1305                             min = datasrc[posk];\par
1306                         \}\par
1307                     \}\par
1308                 \}\par
1309             \}\par
1310 \par
1311             datadst[pos] = min;\par
1312         \}\par
1313     \}\par
1314     {\cf19 return} 1;\par
1315 \}\par
}
}
{\xe \v vc_gray_histogram_equalization\:vc.h}
{\xe \v vc.h\:vc_gray_histogram_equalization}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_gray_histogram_equalization ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst})}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1906 \{\par
1907     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
1908     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
1909     {\cf18 int} width = src->width;\par
1910     {\cf18 int} height = src->height;\par
1911     {\cf18 int} bytesperline_src = src->width * src->channels;\par
1912     {\cf18 int} bytesperline_dst = dst->width * dst->channels;\par
1913     {\cf18 int} total_pixels = width * height;\par
1914     {\cf18 int} histogram[256] = \{0\};\par
1915     {\cf18 int} cumulative_histogram[256] = \{0\};\par
1916 \par
1917     {\cf19 for} ({\cf18 int} y = 0; y < height; y++)\par
1918     \{\par
1919         {\cf19 for} ({\cf18 int} x = 0; x < width; x++)\par
1920         \{\par
1921             {\cf18 int} pos_src = y * bytesperline_src + x;\par
1922             histogram[datasrc[pos_src]]++;\par
1923         \}\par
1924     \}\par
1925 \par
1926     cumulative_histogram[0] = histogram[0];\par
1927     {\cf19 for} ({\cf18 int} i = 1; i < 256; i++)\par
1928     \{\par
1929         cumulative_histogram[i] = cumulative_histogram[i - 1] + histogram[i];\par
1930     \}\par
1931 \par
1932     {\cf18 float} equalization_function[256];\par
1933     {\cf19 for} ({\cf18 int} i = 0; i < 256; i++)\par
1934     \{\par
1935         equalization_function[i] = ((float)cumulative_histogram[i] / total_pixels) * 255;\par
1936     \}\par
1937 \par
1938     {\cf19 for} ({\cf18 int} y = 0; y < height; y++)\par
1939     \{\par
1940         {\cf19 for} ({\cf18 int} x = 0; x < width; x++)\par
1941         \{\par
1942             {\cf18 int} pos_src = y * bytesperline_src + x;\par
1943             {\cf18 int} pos_dst = y * bytesperline_dst + x;\par
1944             datadst[pos_dst] = equalization_function[datasrc[pos_src]];\par
1945         \}\par
1946     \}\par
1947 \par
1948     {\cf19 return} 1;\par
1949 \}\par
}
}
{\xe \v vc_gray_histogram_show\:vc.h}
{\xe \v vc.h\:vc_gray_histogram_show}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_gray_histogram_show ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst})}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1838 \{\par
1839     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
1840     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
1841     {\cf18 int} width = src->width;\par
1842     {\cf18 int} height = src->height;\par
1843     {\cf18 int} bytesperline_src = src->bytesperline;\par
1844     {\cf18 int} bytesperline_dst = dst->bytesperline;\par
1845     {\cf18 int} channels_dst = dst->channels;\par
1846     {\cf18 int} x, y;\par
1847     {\cf18 int} hist[256] = \{0\}; {\cf20 // Initialize histogram array to zero}\par
1848     {\cf18 int} max_count = 0;\par
1849     {\cf18 int} normalized_height[256];\par
1850 \par
1851     {\cf20 // Compute histogram}\par
1852     {\cf19 for} (y = 0; y < height; y++)\par
1853     \{\par
1854         {\cf19 for} (x = 0; x < width; x++)\par
1855         \{\par
1856             {\cf18 int} pixel_value = datasrc[y * bytesperline_src + x]; {\cf20 // Access pixel value}\par
1857             hist[pixel_value]++;\par
1858         \}\par
1859     \}\par
1860 \par
1861     {\cf20 // Find maximum count in histogram for normalization}\par
1862     {\cf19 for} ({\cf18 int} i = 0; i < 256; i++)\par
1863     \{\par
1864         {\cf19 if} (hist[i] > max_count)\par
1865         \{\par
1866             max_count = hist[i];\par
1867         \}\par
1868     \}\par
1869 \par
1870     {\cf20 // Normalize histogram heights}\par
1871     {\cf19 for} ({\cf18 int} i = 0; i < 256; i++)\par
1872     \{\par
1873         normalized_height[i] = (hist[i] * height) / max_count; {\cf20 // Scale to image height}\par
1874     \}\par
1875 \par
1876     {\cf19 for} ({\cf18 int} i = 0; i < 256; i++)\par
1877     \{\par
1878         printf({\cf22 "Intensity %d: %d pixels |||  %d \\n"}, i, normalized_height[i], hist[i]);\par
1879     \}\par
1880 \par
1881     printf({\cf22 "Maximco: %d \\n"}, max_count);\par
1882 \par
1883     {\cf19 for} (y = 0; y < height; y++)\par
1884     \{\par
1885         {\cf19 for} (x = 0; x < 256; x++)\par
1886         \{\par
1887 \par
1888             datadst[y * bytesperline_dst + x * channels_dst] = 0;\par
1889         \}\par
1890     \}\par
1891 \par
1892     {\cf20 // Draw histogram in destination image}\par
1893     {\cf19 for} ({\cf18 int} i = 0; i < 256 && i < width; i++)\par
1894     \{\par
1895         {\cf19 for} (y = height - 1; y >= height - normalized_height[i] && y >= 0; y--)\par
1896         \{\par
1897             {\cf18 long} {\cf18 int} posdst = y * bytesperline_dst + i * channels_dst;\par
1898             datadst[posdst] = 255;\par
1899         \}\par
1900     \}\par
1901 \par
1902     {\cf19 return} 1;\par
1903 \}\par
}
}
{\xe \v vc_gray_negative\:vc.h}
{\xe \v vc.h\:vc_gray_negative}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_gray_negative ({\b IVC} *  {\i srcdst})}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 379 \{\par
380     {\cf18 unsigned} {\cf18 char} *data = ({\cf18 unsigned} {\cf18 char} *)srcdst->data;\par
381     {\cf18 int} width = srcdst->width;\par
382     {\cf18 int} height = srcdst->height;\par
383     {\cf18 int} bytesperline = srcdst->width * srcdst->channels;\par
384     {\cf18 int} channels = srcdst->channels;\par
385     {\cf18 int} x, y;\par
386     {\cf18 long} {\cf18 int} pos;\par
387 \par
388     if ((srcdst->width <= 0) || (srcdst->height <= 0) || (srcdst->data == NULL))\par
389         {\cf19 return} 0;\par
390     {\cf19 if} (channels != 1)\par
391         {\cf19 return} 0;\par
392 \par
393     {\cf19 for} (y = 0; y < height; y++)\par
394     \{\par
395         {\cf19 for} (x = 0; x < width; x++)\par
396         \{\par
397             pos = y * bytesperline + x * channels;\par
398 \par
399             data[pos] = 255 - data[pos];\par
400         \}\par
401     \}\par
402     {\cf19 return} 1;\par
403 \}\par
}
}
{\xe \v vc_gray_open\:vc.h}
{\xe \v vc.h\:vc_gray_open}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_gray_open ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst}, int  {\i kernel})}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1318 \{\par
1319     {\cf18 int} ret = 1;\par
1320     IVC *tmp = vc_image_new(src->width, src->height, src->channels, src->levels);\par
1321 \par
1322     ret &= vc_gray_erode(src, tmp, kernel);\par
1323     ret &= vc_gray_dilate(tmp, dst, kernel);\par
1324 \par
1325     vc_image_free(tmp);\par
1326 \par
1327     {\cf19 return} ret;\par
1328 \}\par
}
}
{\xe \v vc_gray_to_binary\:vc.h}
{\xe \v vc.h\:vc_gray_to_binary}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_gray_to_binary ({\b IVC} *  {\i srcdst}, int  {\i threshold})}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 808 \{\par
809     {\cf18 unsigned} {\cf18 char} *data = ({\cf18 unsigned} {\cf18 char} *)srcdst->data;\par
810     {\cf18 int} width = srcdst->width;\par
811     {\cf18 int} height = srcdst->height;\par
812     {\cf18 int} bytesperline = srcdst->width * srcdst->channels;\par
813     {\cf18 int} channels = srcdst->channels;\par
814     {\cf18 int} x, y, w;\par
815     {\cf18 long} {\cf18 int} pos;\par
816 \par
817     if ((srcdst->width <= 0) || (srcdst->height <= 0) || (srcdst->data == NULL))\par
818         {\cf19 return} 0;\par
819 \par
820     srcdst->levels = 1;\par
821 \par
822     {\cf19 for} (y = 0; y < height; y++)\par
823     \{\par
824         {\cf19 for} (x = 0; x < width; x++)\par
825         \{\par
826             pos = y * bytesperline + x * channels;\par
827 \par
828             {\cf19 if} (data[pos] <= ({\cf18 unsigned} {\cf18 char})threshold)\par
829                 data[pos] = 0;\par
830             {\cf19 else}\par
831                 data[pos] = 255;\par
832         \}\par
833     \}\par
834     {\cf19 return} 1;\par
835 \}\par
}
}
{\xe \v vc_gray_to_binary_bernsen\:vc.h}
{\xe \v vc.h\:vc_gray_to_binary_bernsen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_gray_to_binary_bernsen ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst}, int  {\i kernel}, int  {\i cmin})}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 938 \{\par
939     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
940     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
941     {\cf18 int} width = src->width;\par
942     {\cf18 int} height = src->height;\par
943     {\cf18 int} bytesperline = src->bytesperline;\par
944     {\cf18 int} channels = src->channels;\par
945     {\cf18 int} offset = (kernel - 1) / 2;\par
946     {\cf18 int} x, y, kx, ky;\par
947     {\cf18 int} min, max;\par
948     {\cf18 long} {\cf18 int} pos, posk;\par
949     {\cf18 unsigned} {\cf18 char} threshold;\par
950     {\cf18 int} levels = src->levels;\par
951 \par
952     {\cf20 // Check for valid conditions}\par
953     {\cf19 if} ((src->width <= 0) || (src->height <= 0) || (src->data == NULL))\par
954         {\cf19 return} 0;\par
955     {\cf19 if} ((src->width != dst->width) || (src->height != dst->height) || (src->channels != dst->channels))\par
956         {\cf19 return} 0;\par
957     {\cf19 if} (channels != 1)\par
958         {\cf19 return} 0;\par
959 \par
960     {\cf19 for} (y = 0; y < height; y++)\par
961     \{\par
962         {\cf19 for} (x = 0; x < width; x++)\par
963         \{\par
964             pos = y * bytesperline + x * channels;\par
965 \par
966             max = 0;\par
967             min = 255;\par
968 \par
969             {\cf19 for} (ky = -offset; ky <= offset; ky++)\par
970             \{\par
971                 {\cf19 for} (kx = -offset; kx <= offset; kx++)\par
972                 \{\par
973                     {\cf19 if} ((y + ky >= 0) && (y + ky < height) && (x + kx >= 0) && (x + kx < width))\par
974                     \{\par
975                         posk = (y + ky) * bytesperline + (x + kx) * channels;\par
976 \par
977                         {\cf19 if} (datasrc[posk] > max)\par
978                             max = datasrc[posk];\par
979                         {\cf19 if} (datasrc[posk] < min)\par
980                             min = datasrc[posk];\par
981                     \}\par
982                 \}\par
983             \}\par
984 \par
985             {\cf19 if} ((({\cf18 float})(max - min)) < cmin)\par
986             \{\par
987                 threshold = ({\cf18 unsigned} char)(({\cf18 float})levels / (float)2);\par
988             \}\par
989             {\cf19 else}\par
990             \{\par
991                 threshold = ({\cf18 unsigned} char)(({\cf18 float})(max + min) / ({\cf18 float})2);\par
992             \}\par
993             {\cf19 if} (datasrc[pos] > threshold)\par
994                 datadst[pos] = 255;\par
995             {\cf19 else}\par
996                 datadst[pos] = 0;\par
997         \}\par
998     \}\par
999     {\cf19 return} 1;\par
1000 \}\par
}
}
{\xe \v vc_gray_to_binary_global_mean\:vc.h}
{\xe \v vc.h\:vc_gray_to_binary_global_mean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_gray_to_binary_global_mean ({\b IVC} *  {\i srcdst})}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 838 \{\par
839     {\cf18 unsigned} {\cf18 char} *data = ({\cf18 unsigned} {\cf18 char} *)srcdst->data;\par
840     {\cf18 int} width = srcdst->width;\par
841     {\cf18 int} height = srcdst->height;\par
842     {\cf18 int} bytesperline = srcdst->width * srcdst->channels;\par
843     {\cf18 int} channels = srcdst->channels;\par
844     {\cf18 int} x, y, w;\par
845     {\cf18 long} {\cf18 int} pos, soma = 0;\par
846     {\cf18 int} threshold;\par
847 \par
848     if ((srcdst->width <= 0) || (srcdst->height <= 0) || (srcdst->data == NULL))\par
849         {\cf19 return} 0;\par
850 \par
851     {\cf19 for} (y = 0; y < height; y++)\par
852     \{\par
853 \par
854         {\cf19 for} (x = 0; x < width; x++)\par
855         \{\par
856             pos = y * bytesperline + x * channels;\par
857 \par
858             soma += data[pos];\par
859         \}\par
860     \}\par
861 \par
862     threshold = soma / (width * height);\par
863 \par
864     {\cf19 for} (y = 0; y < height; y++)\par
865     \{\par
866         {\cf19 for} (x = 0; x < width; x++)\par
867         \{\par
868             pos = y * bytesperline + x * channels;\par
869 \par
870             {\cf19 if} (data[pos] <= ({\cf18 unsigned} {\cf18 char})threshold)\par
871                 data[pos] = 0;\par
872             {\cf19 else}\par
873                 data[pos] = 255;\par
874         \}\par
875     \}\par
876 \par
877     {\cf19 return} 1;\par
878 \}\par
}
}
{\xe \v vc_gray_to_binary_midpoint\:vc.h}
{\xe \v vc.h\:vc_gray_to_binary_midpoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_gray_to_binary_midpoint ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst}, int  {\i kernel})}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 881 \{\par
882     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
883     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
884     {\cf18 int} width = src->width;\par
885     {\cf18 int} height = src->height;\par
886     {\cf18 int} bytesperline = src->bytesperline;\par
887     {\cf18 int} channels = src->channels;\par
888     {\cf18 int} offset = (kernel - 1) / 2;\par
889     {\cf18 int} x, y, kx, ky;\par
890     {\cf18 int} min, max;\par
891     {\cf18 long} {\cf18 int} pos, posk;\par
892     {\cf18 unsigned} {\cf18 char} threshold;\par
893 \par
894     {\cf20 // Check for valid conditions}\par
895     {\cf19 if} ((src->width <= 0) || (src->height <= 0) || (src->data == NULL))\par
896         {\cf19 return} 0;\par
897     {\cf19 if} ((src->width != dst->width) || (src->height != dst->height) || (src->channels != dst->channels))\par
898         {\cf19 return} 0;\par
899     {\cf19 if} (channels != 1)\par
900         {\cf19 return} 0;\par
901 \par
902     {\cf19 for} (y = 0; y < height; y++)\par
903     \{\par
904         {\cf19 for} (x = 0; x < width; x++)\par
905         \{\par
906             pos = y * bytesperline + x * channels;\par
907 \par
908             max = 0;\par
909             min = 255;\par
910 \par
911             {\cf19 for} (ky = -offset; ky <= offset; ky++)\par
912             \{\par
913                 {\cf19 for} (kx = -offset; kx <= offset; kx++)\par
914                 \{\par
915                     {\cf19 if} ((y + ky >= 0) && (y + ky < height) && (x + kx >= 0) && (x + kx < width))\par
916                     \{\par
917                         posk = (y + ky) * bytesperline + (x + kx) * channels;\par
918 \par
919                         {\cf19 if} (datasrc[posk] > max)\par
920                             max = datasrc[posk];\par
921                         {\cf19 if} (datasrc[posk] < min)\par
922                             min = datasrc[posk];\par
923                     \}\par
924                 \}\par
925             \}\par
926 \par
927             threshold = ({\cf18 unsigned} char)(({\cf18 float})(max + min) / ({\cf18 float})2);\par
928             {\cf19 if} (datasrc[pos] > threshold)\par
929                 datadst[pos] = 255;\par
930             {\cf19 else}\par
931                 datadst[pos] = 0;\par
932         \}\par
933     \}\par
934     {\cf19 return} 1;\par
935 \}\par
}
}
{\xe \v vc_gray_to_binary_niblack\:vc.h}
{\xe \v vc.h\:vc_gray_to_binary_niblack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_gray_to_binary_niblack ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst}, int  {\i kernel}, float  {\i k})}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1003 \{\par
1004     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
1005     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
1006     {\cf18 int} width = src->width;\par
1007     {\cf18 int} height = src->height;\par
1008     {\cf18 int} bytesperline = src->bytesperline;\par
1009     {\cf18 int} channels = src->channels;\par
1010     {\cf18 int} offset = (kernel - 1) / 2;\par
1011     {\cf18 int} x, y, xx, yy;\par
1012     {\cf18 int} min, max, counter;\par
1013     {\cf18 long} {\cf18 int} pos, posk;\par
1014     {\cf18 unsigned} {\cf18 char} threshold;\par
1015 \par
1016     {\cf20 // Check for valid conditions}\par
1017     {\cf19 if} ((src->width <= 0) || (src->height <= 0) || (src->data == NULL))\par
1018         {\cf19 return} 0;\par
1019     {\cf19 if} ((src->width != dst->width) || (src->height != dst->height) || (src->channels != dst->channels))\par
1020         {\cf19 return} 0;\par
1021     {\cf19 if} (channels != 1)\par
1022         {\cf19 return} 0;\par
1023 \par
1024     {\cf19 for} (y = 0; y < height; y++)\par
1025     \{\par
1026         {\cf19 for} (x = 0; x < width; x++)\par
1027         \{\par
1028             pos = y * bytesperline + x * channels;\par
1029 \par
1030             max = datasrc[pos];\par
1031             min = datasrc[pos];\par
1032 \par
1033             {\cf18 float} mean = 0.0f;\par
1034 \par
1035             {\cf19 for} (counter = 0, yy = -offset; yy <= offset; yy++)\par
1036             \{\par
1037                 {\cf19 for} (xx = -offset; xx <= offset; xx++)\par
1038                 \{\par
1039                     {\cf19 if} ((y + yy >= 0) && (y + yy < height) && (x + xx >= 0) && (x + xx < width))\par
1040                     \{\par
1041                         posk = (y + yy) * bytesperline + (x + xx) * channels;\par
1042 \par
1043                         mean += (float)datasrc[posk];\par
1044 \par
1045                         counter++;\par
1046                     \}\par
1047                 \}\par
1048             \}\par
1049 \par
1050             mean /= counter;\par
1051 \par
1052             {\cf18 float} sdeviatan = 0.0f;\par
1053 \par
1054             {\cf19 for} (counter = 0, yy = -offset; yy <= offset; yy++)\par
1055             \{\par
1056                 {\cf19 for} (xx = -offset; xx <= offset; xx++)\par
1057                 \{\par
1058                     {\cf19 if} ((y + yy >= 0) && (y + yy < height) && (x + xx >= 0) && (x + xx < width))\par
1059                     \{\par
1060                         posk = (y + yy) * bytesperline + (x + xx) * channels;\par
1061 \par
1062                         sdeviatan += powf((({\cf18 float})datasrc[posk]) - mean, 2);\par
1063                         counter++;\par
1064                     \}\par
1065                 \}\par
1066             \}\par
1067             sdeviatan = sqrtf(sdeviatan / counter);\par
1068             threshold = mean + k * sdeviatan;\par
1069 \par
1070             {\cf19 if} (datasrc[pos] > threshold)\par
1071                 datadst[pos] = 255;\par
1072             {\cf19 else}\par
1073                 datadst[pos] = 0;\par
1074         \}\par
1075     \}\par
1076     {\cf19 return} 1;\par
1077 \}\par
}
}
{\xe \v vc_hsv_segmentation\:vc.h}
{\xe \v vc.h\:vc_hsv_segmentation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_hsv_segmentation ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst}, int  {\i hmin}, int  {\i hmax}, int  {\i smin}, int  {\i smax}, int  {\i vmin}, int  {\i vmax})}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 642 \{\par
643     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
644     {\cf18 int} byterperline_src = src->width * src->channels;\par
645     {\cf18 int} channels_src = src->channels;\par
646     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
647     {\cf18 int} bytesperline_dst = dst->width * dst->channels;\par
648     {\cf18 int} channels_dst = dst->channels;\par
649     {\cf18 int} width = src->width;\par
650     {\cf18 int} height = src->height;\par
651     {\cf18 int} x, y;\par
652     {\cf18 long} {\cf18 int} pos_src, pos_dst;\par
653     {\cf18 float} h, s, v;\par
654 \par
655     {\cf19 if} (src->width <= 0 || src->height <= 0 || src->data == NULL)\par
656         {\cf19 return} 0;\par
657     {\cf19 if} (src->width != dst->width || src->height != dst->height)\par
658         {\cf19 return} 0;\par
659     {\cf19 if} (src->channels != 3 || dst->channels != 1)\par
660         {\cf19 return} 0;\par
661 \par
662     {\cf20 // Segmentation loop}\par
663     {\cf19 for} (y = 50; y < 158; y++)\par
664     \{\par
665         {\cf19 for} (x = 0; x < width; x++)\par
666         \{\par
667             pos_src = y * byterperline_src + x * channels_src;\par
668             pos_dst = y * bytesperline_dst + x * channels_dst;\par
669 \par
670             {\cf20 // Assuming HSV values are stored in src and are normalized [0, 255]}\par
671             h = (int)((({\cf18 float})datasrc[pos_src]) / 255.0f * 360.0f);\par
672             s = (int)((({\cf18 float})datasrc[pos_src + 1]) / 255.0f * 100.0f);\par
673             v = (int)((({\cf18 float})datasrc[pos_src + 2]) / 255.0f * 100.0f);\par
674 \par
675             {\cf20 // Check if the pixel falls within the specified HSV range}\par
676             {\cf19 if} (h >= hmin && h <= hmax && s >= smin && s <= smax && v >= vmin && v <= vmax)\par
677             \{\par
678                 datadst[pos_dst] = 255; {\cf20 // Pixel is within range, mark as white}\par
679             \}\par
680             {\cf19 else}\par
681             \{\par
682                 datadst[pos_dst] = 0; {\cf20 // Pixel is outside range, mark as black}\par
683             \}\par
684         \}\par
685     \}\par
686 \par
687     {\cf19 return} 1; {\cf20 // Success}\par
688 \}\par
}
}
{\xe \v vc_hsv_segmentation_castanho\:vc.h}
{\xe \v vc.h\:vc_hsv_segmentation_castanho}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_hsv_segmentation_castanho ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst})}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2273 \{\par
2274     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
2275     {\cf18 int} byterperline_src = src->width * src->channels;\par
2276     {\cf18 int} channels_src = src->channels;\par
2277     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
2278     {\cf18 int} bytesperline_dst = dst->width * dst->channels;\par
2279     {\cf18 int} channels_dst = dst->channels;\par
2280     {\cf18 int} width = src->width;\par
2281     {\cf18 int} height = src->height;\par
2282     {\cf18 int} x, y;\par
2283     {\cf18 long} {\cf18 int} pos_src, pos_dst;\par
2284     {\cf18 float} h, s, v;\par
2285 \par
2286     {\cf19 if} (src->width <= 0 || src->height <= 0 || src->data == NULL)\par
2287         {\cf19 return} 0;\par
2288     {\cf19 if} (src->width != dst->width || src->height != dst->height)\par
2289         {\cf19 return} 0;\par
2290     {\cf19 if} (src->channels != 3 || dst->channels != 1)\par
2291         {\cf19 return} 0;\par
2292 \par
2293     {\cf20 // Segmentation loop}\par
2294     {\cf19 for} (y = 50; y < 158; y++)\par
2295     \{\par
2296         {\cf19 for} (x = 0; x < width; x++)\par
2297         \{\par
2298             pos_src = y * byterperline_src + x * channels_src;\par
2299             pos_dst = y * bytesperline_dst + x * channels_dst;\par
2300 \par
2301             {\cf20 // Assuming HSV values are stored in src and are normalized [0, 255]}\par
2302             h = (int)((({\cf18 float})datasrc[pos_src]) / 255.0f * 360.0f);\par
2303             s = (int)((({\cf18 float})datasrc[pos_src + 1]) / 255.0f * 100.0f);\par
2304             v = (int)((({\cf18 float})datasrc[pos_src + 2]) / 255.0f * 100.0f);\par
2305 \par
2306             {\cf20 // Check if the pixel falls within the specified HSV range}\par
2307             {\cf19 if} ((h >= 10 && h <= 30 && s >= 23 && s <= 46 && v >= 329 && v <= 51) || (h >= 9 && h <= 25 && s >= 39 && s <= 61 && v >= 38 && v <= 61))\par
2308             \{\par
2309                 datadst[pos_dst] = 255; {\cf20 // Pixel is within range, mark as white}\par
2310             \}\par
2311             {\cf19 else}\par
2312             \{\par
2313                 datadst[pos_dst] = 0; {\cf20 // Pixel is outside range, mark as black}\par
2314             \}\par
2315         \}\par
2316     \}\par
2317 \par
2318     {\cf19 return} 1; {\cf20 // Success}\par
2319 \}\par
}
}
{\xe \v vc_hsv_segmentation_final\:vc.h}
{\xe \v vc.h\:vc_hsv_segmentation_final}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_hsv_segmentation_final ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst})}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2322 \{\par
2323     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
2324     {\cf18 int} byterperline_src = src->width * src->channels;\par
2325     {\cf18 int} channels_src = src->channels;\par
2326     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
2327     {\cf18 int} bytesperline_dst = dst->width * dst->channels;\par
2328     {\cf18 int} channels_dst = dst->channels;\par
2329     {\cf18 int} width = src->width;\par
2330     {\cf18 int} height = src->height;\par
2331     {\cf18 int} x, y;\par
2332     {\cf18 long} {\cf18 int} pos_src, pos_dst;\par
2333     {\cf18 float} h, s, v;\par
2334 \par
2335     {\cf19 if} (src->width <= 0 || src->height <= 0 || src->data == NULL)\par
2336         {\cf19 return} 0;\par
2337     {\cf19 if} (src->width != dst->width || src->height != dst->height)\par
2338         {\cf19 return} 0;\par
2339     {\cf19 if} (src->channels != 3 || dst->channels != 1)\par
2340         {\cf19 return} 0;\par
2341 \par
2342     {\cf20 // Segmentation loop}\par
2343     {\cf19 for} (y = 0; y < height; y++)\par
2344     \{\par
2345         {\cf19 for} (x = 0; x < width; x++)\par
2346         \{\par
2347             pos_src = y * byterperline_src + x * channels_src;\par
2348             pos_dst = y * bytesperline_dst + x * channels_dst;\par
2349 \par
2350             {\cf20 // Assuming HSV values are stored in src and are normalized [0, 255]}\par
2351             h = (int)((({\cf18 float})datasrc[pos_src]) / 255.0f * 360.0f);\par
2352             s = (int)((({\cf18 float})datasrc[pos_src + 1]) / 255.0f * 100.0f);\par
2353             v = (int)((({\cf18 float})datasrc[pos_src + 2]) / 255.0f * 100.0f);\par
2354 \par
2355             {\cf20 // Check if the pixel falls within the specified HSV range}\par
2356             {\cf19 if} ((h >= 12 && h <= 28 && s >= 25 && s <= 44 && v >= 31 && v <= 49) || (h >= 11 && h <= 23 && s >= 42 && s <= 58 && v >= 41 && v <= 58) || (h >= 0 && h <= 11 && s >= 45 && s <= 69 && v >= 55 && v <= 89) || (h >= 354 && h <= 360 && s >= 45 && s <= 75 && v >= 55 && v <= 75) || (h >= 79 && h <= 105 && s >= 28 && s <= 45 && v >= 35 && v <= 50) || (h >= 155 && h <= 200 && s >= 16 && s <= 40 && v >= 36 && v <= 52) || (h >= 35 && h <= 200 && s >= 3 && s <= 19 && v >= 15 && v <= 37) || (h >= 6 && h <= 12 && s >= 68 && s <= 78 && v >= 80 && v <= 92) || (h >= 29 && h <= 46 && s >= 31 && s <= 62 && v >= 54 && v <= 91) || (h >= 29 && h <= 38 && s >= 33 && s <= 46 && v >= 46 && v <= 56))\par
2357             \{\par
2358                 datadst[pos_dst] = 255; {\cf20 // Pixel is within range, mark as white}\par
2359             \}\par
2360             {\cf19 else}\par
2361             \{\par
2362                 datadst[pos_dst] = 0; {\cf20 // Pixel is outside range, mark as black}\par
2363             \}\par
2364         \}\par
2365     \}\par
2366 \par
2367     {\cf19 return} 1; {\cf20 // Success}\par
2368 \}\par
}
}
{\xe \v vc_hsv_segmentation_resistencias\:vc.h}
{\xe \v vc.h\:vc_hsv_segmentation_resistencias}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_hsv_segmentation_resistencias ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst})}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2371 \{\par
2372     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
2373     {\cf18 int} byterperline_src = src->width * src->channels;\par
2374     {\cf18 int} channels_src = src->channels;\par
2375     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
2376     {\cf18 int} bytesperline_dst = dst->width * dst->channels;\par
2377     {\cf18 int} channels_dst = dst->channels;\par
2378     {\cf18 int} width = src->width;\par
2379     {\cf18 int} height = src->height;\par
2380     {\cf18 int} x, y;\par
2381     {\cf18 long} {\cf18 int} pos_src, pos_dst;\par
2382     {\cf18 float} h, s, v;\par
2383 \par
2384     {\cf19 if} (src->width <= 0 || src->height <= 0 || src->data == NULL)\par
2385         {\cf19 return} 0;\par
2386     {\cf19 if} (src->width != dst->width || src->height != dst->height)\par
2387         {\cf19 return} 0;\par
2388     {\cf19 if} (src->channels != 3 || dst->channels != 1)\par
2389         {\cf19 return} 0;\par
2390 \par
2391     {\cf20 // Segmentation loop}\par
2392     {\cf19 for} (y = 0; y < height; y++)\par
2393     \{\par
2394         {\cf19 for} (x = 0; x < width; x++)\par
2395         \{\par
2396             pos_src = y * byterperline_src + x * channels_src;\par
2397             pos_dst = y * bytesperline_dst + x * channels_dst;\par
2398 \par
2399             {\cf20 // Assuming HSV values are stored in src and are normalized [0, 255]}\par
2400             h = (int)((({\cf18 float})datasrc[pos_src]) / 255.0f * 360.0f);\par
2401             s = (int)((({\cf18 float})datasrc[pos_src + 1]) / 255.0f * 100.0f);\par
2402             v = (int)((({\cf18 float})datasrc[pos_src + 2]) / 255.0f * 100.0f);\par
2403 \par
2404             {\cf20 // Check if the pixel falls within the specified HSV range}\par
2405             {\cf19 if} ((h >= 12 && h <= 28 && s >= 25 && s <= 44 && v >= 31 && v <= 49) || (h >= 11 && h <= 23 && s >= 42 && s <= 58 && v >= 41 && v <= 58) || (h >= 0 && h <= 11 && s >= 45 && s <= 69 && v >= 55 && v <= 89) || (h >= 354 && h <= 360 && s >= 45 && s <= 75 && v >= 55 && v <= 75) || (h >= 79 && h <= 105 && s >= 28 && s <= 45 && v >= 35 && v <= 50) || (h >= 155 && h <= 200 && s >= 16 && s <= 40 && v >= 36 && v <= 52) || (h >= 35 && h <= 200 && s >= 3 && s <= 19 && v >= 15 && v <= 37) || (h >= 6 && h <= 12 && s >= 68 && s <= 78 && v >= 80 && v <= 92))\par
2406             \{\par
2407                 datadst[pos_dst] = 255; {\cf20 // Pixel is within range, mark as white}\par
2408             \}\par
2409             {\cf19 else}\par
2410             \{\par
2411                 datadst[pos_dst] = 0; {\cf20 // Pixel is outside range, mark as black}\par
2412             \}\par
2413         \}\par
2414     \}\par
2415 \par
2416     {\cf19 return} 1; {\cf20 // Success}\par
2417 \}\par
}
}
{\xe \v vc_hsv_segmentation_vermelho\:vc.h}
{\xe \v vc.h\:vc_hsv_segmentation_vermelho}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_hsv_segmentation_vermelho ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst})}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2224 \{\par
2225     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
2226     {\cf18 int} byterperline_src = src->width * src->channels;\par
2227     {\cf18 int} channels_src = src->channels;\par
2228     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
2229     {\cf18 int} bytesperline_dst = dst->width * dst->channels;\par
2230     {\cf18 int} channels_dst = dst->channels;\par
2231     {\cf18 int} width = src->width;\par
2232     {\cf18 int} height = src->height;\par
2233     {\cf18 int} x, y;\par
2234     {\cf18 long} {\cf18 int} pos_src, pos_dst;\par
2235     {\cf18 float} h, s, v;\par
2236 \par
2237     {\cf19 if} (src->width <= 0 || src->height <= 0 || src->data == NULL)\par
2238         {\cf19 return} 0;\par
2239     {\cf19 if} (src->width != dst->width || src->height != dst->height)\par
2240         {\cf19 return} 0;\par
2241     {\cf19 if} (src->channels != 3 || dst->channels != 1)\par
2242         {\cf19 return} 0;\par
2243 \par
2244     {\cf20 // Segmentation loop}\par
2245     {\cf19 for} (y = 50; y < 158; y++)\par
2246     \{\par
2247         {\cf19 for} (x = 0; x < width; x++)\par
2248         \{\par
2249             pos_src = y * byterperline_src + x * channels_src;\par
2250             pos_dst = y * bytesperline_dst + x * channels_dst;\par
2251 \par
2252             {\cf20 // Assuming HSV values are stored in src and are normalized [0, 255]}\par
2253             h = (int)((({\cf18 float})datasrc[pos_src]) / 255.0f * 360.0f);\par
2254             s = (int)((({\cf18 float})datasrc[pos_src + 1]) / 255.0f * 100.0f);\par
2255             v = (int)((({\cf18 float})datasrc[pos_src + 2]) / 255.0f * 100.0f);\par
2256 \par
2257             {\cf20 // Check if the pixel falls within the specified HSV range}\par
2258             {\cf19 if} ((h >= 0 && h <= 11 && s >= 45 && s <= 69 && v >= 55 && v <= 89) || (h >= 354 && h <= 360 && s >= 45 && s <= 75 && v >= 55 && v <= 75))\par
2259             \{\par
2260                 datadst[pos_dst] = 255; {\cf20 // Pixel is within range, mark as white}\par
2261             \}\par
2262             {\cf19 else}\par
2263             \{\par
2264                 datadst[pos_dst] = 0; {\cf20 // Pixel is outside range, mark as black}\par
2265             \}\par
2266         \}\par
2267     \}\par
2268 \par
2269     {\cf19 return} 1; {\cf20 // Success}\par
2270 \}\par
}
}
{\xe \v vc_image_free\:vc.h}
{\xe \v vc.h\:vc_image_free}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IVC} * vc_image_free ({\b IVC} *  {\i image})}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 53 \{\par
54     {\cf19 if} (image != NULL)\par
55     \{\par
56         {\cf19 if} (image->data != NULL)\par
57         \{\par
58             free(image->data);\par
59             image->data = NULL;\par
60         \}\par
61 \par
62         free(image);\par
63         image = NULL;\par
64     \}\par
65 \par
66     {\cf19 return} image;\par
67 \}\par
}
}
{\xe \v vc_image_new\:vc.h}
{\xe \v vc.h\:vc_image_new}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IVC} * vc_image_new (int  {\i width}, int  {\i height}, int  {\i channels}, int  {\i levels})}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28 \{\par
29     IVC *image = (IVC *)malloc({\cf17 sizeof}(IVC));\par
30 \par
31     {\cf19 if} (image == NULL)\par
32         {\cf19 return} NULL;\par
33     {\cf19 if} ((levels <= 0) || (levels > 255))\par
34         {\cf19 return} NULL;\par
35 \par
36     image->width = width;\par
37     image->height = height;\par
38     image->channels = channels;\par
39     image->levels = levels;\par
40     image->bytesperline = image->width * image->channels;\par
41     image->data = ({\cf18 unsigned} {\cf18 char} *)malloc(image->width * image->height * image->channels * {\cf17 sizeof}({\cf18 char}));\par
42 \par
43     {\cf19 if} (image->data == NULL)\par
44     \{\par
45         {\cf19 return} vc_image_free(image);\par
46     \}\par
47 \par
48     {\cf19 return} image;\par
49 \}\par
}
}
{\xe \v vc_read_image\:vc.h}
{\xe \v vc.h\:vc_read_image}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IVC} * vc_read_image (char *  {\i filename})}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 193 \{\par
194     FILE *file = NULL;\par
195     IVC *image = NULL;\par
196     {\cf18 unsigned} {\cf18 char} *tmp;\par
197     {\cf18 char} tok[20];\par
198     {\cf18 long} {\cf18 int} size, sizeofbinarydata;\par
199     {\cf18 int} width, height, channels;\par
200     {\cf18 int} levels = 255;\par
201     {\cf18 int} v;\par
202 \par
203     {\cf20 // Abre o ficheiro}\par
204     {\cf19 if} ((file = fopen(filename, {\cf22 "rb"})) != NULL)\par
205     \{\par
206         {\cf20 // Efectua a leitura do header}\par
207         netpbm_get_token(file, tok, {\cf17 sizeof}(tok));\par
208 \par
209         {\cf19 if} (strcmp(tok, {\cf22 "P4"}) == 0)\par
210         \{\par
211             channels = 1;\par
212             levels = 1;\par
213         \} {\cf20 // Se PBM (Binary [0,1])}\par
214         {\cf19 else} {\cf19 if} (strcmp(tok, {\cf22 "P5"}) == 0)\par
215             channels = 1; {\cf20 // Se PGM (Gray [0,MY_MAX(level,255)])}\par
216         {\cf19 else} {\cf19 if} (strcmp(tok, {\cf22 "P6"}) == 0)\par
217             channels = 3; {\cf20 // Se PPM (RGB [0,MY_MAX(level,255)])}\par
218         {\cf19 else}\par
219         \{\par
220 {\cf21 #ifdef VC_DEBUG}\par
221             printf({\cf22 "ERROR -> vc_read_image():\\n\\tFile is not a valid PBM, PGM or PPM file.\\n\\tBad magic number!\\n"});\par
222 {\cf21 #endif}\par
223 \par
224             fclose(file);\par
225             {\cf19 return} NULL;\par
226         \}\par
227 \par
228         {\cf19 if} (levels == 1) {\cf20 // PBM}\par
229         \{\par
230             {\cf19 if} (sscanf(netpbm_get_token(file, tok, {\cf17 sizeof}(tok)), {\cf22 "%d"}, &width) != 1 ||\par
231                 sscanf(netpbm_get_token(file, tok, {\cf17 sizeof}(tok)), {\cf22 "%d"}, &height) != 1)\par
232             \{\par
233 {\cf21 #ifdef VC_DEBUG}\par
234                 printf({\cf22 "ERROR -> vc_read_image():\\n\\tFile is not a valid PBM file.\\n\\tBad size!\\n"});\par
235 {\cf21 #endif}\par
236 \par
237                 fclose(file);\par
238                 {\cf19 return} NULL;\par
239             \}\par
240 \par
241             {\cf20 // Aloca mem\'EF\'BF\'BDria para imagem}\par
242             image = vc_image_new(width, height, channels, levels);\par
243             {\cf19 if} (image == NULL)\par
244                 {\cf19 return} NULL;\par
245 \par
246             sizeofbinarydata = (image->width / 8 + ((image->width % 8) ? 1 : 0)) * image->height;\par
247             tmp = ({\cf18 unsigned} {\cf18 char} *)malloc(sizeofbinarydata);\par
248             {\cf19 if} (tmp == NULL)\par
249                 {\cf19 return} 0;\par
250 \par
251 {\cf21 #ifdef VC_DEBUG}\par
252             printf({\cf22 "\\nchannels=%d w=%d h=%d levels=%d\\n"}, image->channels, image->width, image->height, levels);\par
253 {\cf21 #endif}\par
254 \par
255             {\cf19 if} ((v = fread(tmp, {\cf17 sizeof}({\cf18 unsigned} {\cf18 char}), sizeofbinarydata, file)) != sizeofbinarydata)\par
256             \{\par
257 {\cf21 #ifdef VC_DEBUG}\par
258                 printf({\cf22 "ERROR -> vc_read_image():\\n\\tPremature EOF on file.\\n"});\par
259 {\cf21 #endif}\par
260 \par
261                 vc_image_free(image);\par
262                 fclose(file);\par
263                 free(tmp);\par
264                 {\cf19 return} NULL;\par
265             \}\par
266 \par
267             bit_to_unsigned_char(tmp, image->data, image->width, image->height);\par
268 \par
269             free(tmp);\par
270         \}\par
271         {\cf19 else} {\cf20 // PGM ou PPM}\par
272         \{\par
273             {\cf19 if} (sscanf(netpbm_get_token(file, tok, {\cf17 sizeof}(tok)), {\cf22 "%d"}, &width) != 1 ||\par
274                 sscanf(netpbm_get_token(file, tok, {\cf17 sizeof}(tok)), {\cf22 "%d"}, &height) != 1 ||\par
275                 sscanf(netpbm_get_token(file, tok, {\cf17 sizeof}(tok)), {\cf22 "%d"}, &levels) != 1 || levels <= 0 || levels > 255)\par
276             \{\par
277 {\cf21 #ifdef VC_DEBUG}\par
278                 printf({\cf22 "ERROR -> vc_read_image():\\n\\tFile is not a valid PGM or PPM file.\\n\\tBad size!\\n"});\par
279 {\cf21 #endif}\par
280 \par
281                 fclose(file);\par
282                 {\cf19 return} NULL;\par
283             \}\par
284 \par
285             {\cf20 // Aloca mem\'EF\'BF\'BDria para imagem}\par
286             image = vc_image_new(width, height, channels, levels);\par
287             {\cf19 if} (image == NULL)\par
288                 {\cf19 return} NULL;\par
289 \par
290 {\cf21 #ifdef VC_DEBUG}\par
291             printf({\cf22 "\\nchannels=%d w=%d h=%d levels=%d\\n"}, image->channels, image->width, image->height, levels);\par
292 {\cf21 #endif}\par
293 \par
294             size = image->width * image->height * image->channels;\par
295 \par
296             {\cf19 if} ((v = fread(image->data, {\cf17 sizeof}({\cf18 unsigned} {\cf18 char}), size, file)) != size)\par
297             \{\par
298 {\cf21 #ifdef VC_DEBUG}\par
299                 printf({\cf22 "ERROR -> vc_read_image():\\n\\tPremature EOF on file.\\n"});\par
300 {\cf21 #endif}\par
301 \par
302                 vc_image_free(image);\par
303                 fclose(file);\par
304                 {\cf19 return} NULL;\par
305             \}\par
306         \}\par
307 \par
308         fclose(file);\par
309     \}\par
310     {\cf19 else}\par
311     \{\par
312 {\cf21 #ifdef VC_DEBUG}\par
313         printf({\cf22 "ERROR -> vc_read_image():\\n\\tFile not found.\\n"});\par
314 {\cf21 #endif}\par
315     \}\par
316 \par
317     {\cf19 return} image;\par
318 \}\par
}
}
{\xe \v vc_rgb_get_blue_gray\:vc.h}
{\xe \v vc.h\:vc_rgb_get_blue_gray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_rgb_get_blue_gray ({\b IVC} *  {\i srcdst})}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 498 \{\par
499     {\cf18 unsigned} {\cf18 char} *data = ({\cf18 unsigned} {\cf18 char} *)srcdst->data;\par
500     {\cf18 int} width = srcdst->width;\par
501     {\cf18 int} height = srcdst->height;\par
502     {\cf18 int} bytesperline = srcdst->width * srcdst->channels;\par
503     {\cf18 int} channels = srcdst->channels;\par
504     {\cf18 int} x, y;\par
505     {\cf18 long} {\cf18 int} pos;\par
506 \par
507     {\cf20 // Verifica\'E7\'E3o de erros}\par
508     if ((srcdst->width <= 0) || (srcdst->height <= 0) || (srcdst->data == NULL))\par
509         {\cf19 return} 0;\par
510     {\cf19 if} (channels != 3)\par
511         {\cf19 return} 0;\par
512 \par
513     {\cf20 // Extrai a componente RED}\par
514     {\cf19 for} (y = 0; y < height; y++)\par
515     \{\par
516         {\cf19 for} (x = 0; x < width; x++)\par
517         \{\par
518             pos = y * bytesperline + x * channels;\par
519 \par
520             data[pos] = data[pos + 2];\par
521             data[pos + 1] = data[pos + 2];\par
522         \}\par
523     \}\par
524 \par
525     {\cf19 return} 1;\par
526 \};\par
}
}
{\xe \v vc_rgb_get_green_gray\:vc.h}
{\xe \v vc.h\:vc_rgb_get_green_gray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_rgb_get_green_gray ({\b IVC} *  {\i srcdst})}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 467 \{\par
468     {\cf18 unsigned} {\cf18 char} *data = ({\cf18 unsigned} {\cf18 char} *)srcdst->data;\par
469     {\cf18 int} width = srcdst->width;\par
470     {\cf18 int} height = srcdst->height;\par
471     {\cf18 int} bytesperline = srcdst->width * srcdst->channels;\par
472     {\cf18 int} channels = srcdst->channels;\par
473     {\cf18 int} x, y;\par
474     {\cf18 long} {\cf18 int} pos;\par
475 \par
476     {\cf20 // Verifica\'E7\'E3o de erros}\par
477     if ((srcdst->width <= 0) || (srcdst->height <= 0) || (srcdst->data == NULL))\par
478         {\cf19 return} 0;\par
479     {\cf19 if} (channels != 3)\par
480         {\cf19 return} 0;\par
481 \par
482     {\cf20 // Extrai a componente RED}\par
483     {\cf19 for} (y = 0; y < height; y++)\par
484     \{\par
485         {\cf19 for} (x = 0; x < width; x++)\par
486         \{\par
487             pos = y * bytesperline + x * channels;\par
488 \par
489             data[pos] = data[pos + 1];\par
490             data[pos + 2] = data[pos + 1];\par
491         \}\par
492     \}\par
493 \par
494     {\cf19 return} 1;\par
495 \};\par
}
}
{\xe \v vc_rgb_get_red_gray\:vc.h}
{\xe \v vc.h\:vc_rgb_get_red_gray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_rgb_get_red_gray ({\b IVC} *  {\i srcdst})}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 436 \{\par
437     {\cf18 unsigned} {\cf18 char} *data = ({\cf18 unsigned} {\cf18 char} *)srcdst->data;\par
438     {\cf18 int} width = srcdst->width;\par
439     {\cf18 int} height = srcdst->height;\par
440     {\cf18 int} bytesperline = srcdst->width * srcdst->channels;\par
441     {\cf18 int} channels = srcdst->channels;\par
442     {\cf18 int} x, y;\par
443     {\cf18 long} {\cf18 int} pos;\par
444 \par
445     {\cf20 // Verifica\'E7\'E3o de erros}\par
446     if ((srcdst->width <= 0) || (srcdst->height <= 0) || (srcdst->data == NULL))\par
447         {\cf19 return} 0;\par
448     {\cf19 if} (channels != 3)\par
449         {\cf19 return} 0;\par
450 \par
451     {\cf20 // Extrai a componente RED}\par
452     {\cf19 for} (y = 0; y < height; y++)\par
453     \{\par
454         {\cf19 for} (x = 0; x < width; x++)\par
455         \{\par
456             pos = y * bytesperline + x * channels;\par
457 \par
458             data[pos + 1] = data[pos]; {\cf20 // Green}\par
459             data[pos + 2] = data[pos]; {\cf20 // Blue}\par
460         \}\par
461     \}\par
462 \par
463     {\cf19 return} 1;\par
464 \};\par
}
}
{\xe \v vc_rgb_negative\:vc.h}
{\xe \v vc.h\:vc_rgb_negative}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_rgb_negative ({\b IVC} *  {\i srcdst})}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 406 \{\par
407     {\cf18 unsigned} {\cf18 char} *data = ({\cf18 unsigned} {\cf18 char} *)srcdst->data;\par
408     {\cf18 int} width = srcdst->width;\par
409     {\cf18 int} height = srcdst->height;\par
410     {\cf18 int} bytesperline = srcdst->width * srcdst->channels;\par
411     {\cf18 int} channels = srcdst->channels;\par
412     {\cf18 int} x, y;\par
413     {\cf18 long} {\cf18 int} pos;\par
414 \par
415     if ((srcdst->width <= 0) || (srcdst->height <= 0) || (srcdst->data == NULL))\par
416         {\cf19 return} 0;\par
417     {\cf19 if} (channels != 3)\par
418         {\cf19 return} 0;\par
419 \par
420     {\cf19 for} (y = 0; y < height; y++)\par
421     \{\par
422         {\cf19 for} (x = 0; x < width; x++)\par
423         \{\par
424             pos = y * bytesperline + x * channels;\par
425 \par
426             data[pos] = 255 - data[pos];\par
427             data[pos + 1] = 255 - data[pos + 1];\par
428             data[pos + 2] = 255 - data[pos + 2];\par
429         \}\par
430     \}\par
431 \par
432     {\cf19 return} 1;\par
433 \}\par
}
}
{\xe \v vc_rgb_to_gray\:vc.h}
{\xe \v vc.h\:vc_rgb_to_gray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_rgb_to_gray ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst})}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 529 \{\par
530     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
531     {\cf18 int} byterperline_src = src->width * src->channels;\par
532     {\cf18 int} channels_src = src->channels;\par
533     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
534     {\cf18 int} bytesperline_dst = dst->width * dst->channels;\par
535     {\cf18 int} channels_dst = dst->channels;\par
536     {\cf18 int} width = src->width;\par
537     {\cf18 int} height = src->height;\par
538     {\cf18 int} x, y;\par
539     {\cf18 long} {\cf18 int} pos_src, pos_dst;\par
540     {\cf18 float} rf, gf, bf;\par
541 \par
542     {\cf19 if} (src->width <= 0 || src->height <= 0 || src->data == NULL)\par
543         {\cf19 return} 0;\par
544     {\cf19 if} (src->width != dst->width || src->height != dst->height)\par
545         {\cf19 return} 0;\par
546     {\cf19 if} (src->channels != 3 || dst->channels != 1)\par
547         {\cf19 return} 0;\par
548 \par
549     {\cf19 for} (y = 0; y < height; y++)\par
550     \{\par
551         {\cf19 for} (x = 0; x < width; x++)\par
552         \{\par
553             pos_src = y * byterperline_src + x * channels_src;\par
554             pos_dst = y * bytesperline_dst + x * channels_dst;\par
555 \par
556             rf = (float)datasrc[pos_src];\par
557             gf = (float)datasrc[pos_src + 1];\par
558             bf = (float)datasrc[pos_src + 2];\par
559 \par
560             datadst[pos_dst] = ({\cf18 unsigned} char)((rf * 0.299) + (gf * 0.587) + (bf * 0.114));\par
561         \}\par
562     \}\par
563     {\cf19 return} 1;\par
564 \}\par
}
}
{\xe \v vc_rgb_to_hsv\:vc.h}
{\xe \v vc.h\:vc_rgb_to_hsv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_rgb_to_hsv ({\b IVC} *  {\i srcdst})}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 567 \{\par
568     {\cf18 unsigned} {\cf18 char} *data = ({\cf18 unsigned} {\cf18 char} *)srcdst->data;\par
569     {\cf18 int} width = srcdst->width;\par
570     {\cf18 int} height = srcdst->height;\par
571     {\cf18 int} bytesperline = srcdst->bytesperline;\par
572     {\cf18 int} channels = srcdst->channels;\par
573     {\cf18 float} r, g, b, saturation, hue, value;\par
574     {\cf18 int} i, size;\par
575     {\cf18 int} pos_src;\par
576     {\cf18 float} rgb_max;\par
577     {\cf18 float} rgb_min;\par
578 \par
579     if ((srcdst->width <= 0) || (srcdst->height <= 0) || (srcdst->data == NULL))\par
580         {\cf19 return} 0;\par
581     {\cf19 if} (channels != 3)\par
582         {\cf19 return} 0;\par
583 \par
584     size = width * height * channels;\par
585 \par
586     {\cf19 for} (i = 0; i < size; i += channels)\par
587     \{\par
588         pos_src = i;\par
589 \par
590         r = (float)data[pos_src];\par
591         g = (float)data[pos_src + 1];\par
592         b = (float)data[pos_src + 2];\par
593 \par
594         rgb_max = fmaxf(r, fmaxf(g, b));\par
595         rgb_min = fminf(r, fminf(g, b));\par
596 \par
597         value = rgb_max;\par
598 \par
599         {\cf19 if} (value == 0.0f)\par
600         \{\par
601             hue = 0.0f;\par
602             saturation = 0.0f;\par
603         \}\par
604         {\cf19 else}\par
605         \{\par
606             saturation = ((rgb_max - rgb_min) / rgb_max) * 255.0f;\par
607 \par
608             {\cf19 if} (saturation == 0.0f)\par
609             \{\par
610                 hue = 0.0f;\par
611             \}\par
612             {\cf19 else}\par
613             \{\par
614                 {\cf19 if} ((rgb_max == r) && (g >= b))\par
615                 \{\par
616                     hue = 60.0f * (g - b) / (rgb_max - rgb_min);\par
617                 \}\par
618                 {\cf19 else} {\cf19 if} ((rgb_max == r) && (b > g))\par
619                 \{\par
620                     hue = 360 + 60 * (g - b) / (rgb_max - rgb_min);\par
621                 \}\par
622                 {\cf19 else} {\cf19 if} (rgb_max == g)\par
623                 \{\par
624                     hue = 120 + 60 * (b - r) / (rgb_max - rgb_min);\par
625                 \}\par
626                 {\cf19 else} {\cf19 if} (rgb_max == b)\par
627                 \{\par
628                     hue = 240 + 60 * (r - g) / (rgb_max - rgb_min);\par
629                 \}\par
630             \}\par
631         \}\par
632 \par
633         data[i] = ({\cf18 unsigned} char)(hue / 360.0f * 255.0f);\par
634         data[i + 1] = ({\cf18 unsigned} char)(saturation);\par
635         data[i + 2] = ({\cf18 unsigned} char)(value);\par
636     \}\par
637 \par
638     {\cf19 return} 1;\par
639 \}\par
}
}
{\xe \v vc_scale_gray_to_rgb\:vc.h}
{\xe \v vc.h\:vc_scale_gray_to_rgb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_scale_gray_to_rgb ({\b IVC} *  {\i src}, {\b IVC} *  {\i dst})}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 691 \{\par
692     {\cf18 unsigned} {\cf18 char} *datasrc = ({\cf18 unsigned} {\cf18 char} *)src->data;\par
693     {\cf18 int} byterperline_src = src->width * src->channels;\par
694     {\cf18 int} channels_src = src->channels;\par
695     {\cf18 unsigned} {\cf18 char} *datadst = ({\cf18 unsigned} {\cf18 char} *)dst->data;\par
696     {\cf18 int} bytesperline_dst = dst->width * dst->channels;\par
697     {\cf18 int} channels_dst = dst->channels;\par
698     {\cf18 int} width = src->width;\par
699     {\cf18 int} height = src->height;\par
700     {\cf18 int} x, y;\par
701     {\cf18 long} {\cf18 int} pos_src, pos_dst;\par
702     {\cf18 unsigned} {\cf18 char} gray, red, green, blue;\par
703 \par
704     {\cf20 // Check for valid conditions}\par
705     {\cf19 if} (src->width <= 0 || src->height <= 0 || src->data == NULL)\par
706         {\cf19 return} 0;\par
707     {\cf19 if} (src->width != dst->width || src->height != dst->height)\par
708         {\cf19 return} 0;\par
709     {\cf19 if} (src->channels != 1 || dst->channels != 3)\par
710         {\cf19 return} 0;\par
711 \par
712     {\cf19 for} ({\cf18 int} y = 0; y < height; y++)\par
713     \{\par
714         {\cf19 for} ({\cf18 int} x = 0; x < width; x++)\par
715         \{\par
716             pos_src = y * byterperline_src + x * channels_src;\par
717             pos_dst = y * bytesperline_dst + x * channels_dst;\par
718 \par
719             gray = datasrc[pos_src];\par
720 \par
721             {\cf19 if} (gray < 128)\par
722                 red = 0;\par
723             {\cf19 else} {\cf19 if} (gray >= 128 && gray <= 192)\par
724                 red = ({\cf18 unsigned} char)(((gray - 128) / 64.0) * 255);\par
725             {\cf19 else}\par
726                 red = 255;\par
727 \par
728             {\cf19 if} (gray <= 64)\par
729                 green = ({\cf18 unsigned} char)((gray / 64.0) * 255);\par
730             {\cf19 else} {\cf19 if} (gray > 64 && gray <= 192)\par
731                 green = 255;\par
732             {\cf19 else}\par
733                 green = ({\cf18 unsigned} char)(((255 - gray) / 63.0) * 255);\par
734 \par
735             {\cf19 if} (gray <= 64)\par
736                 blue = 255;\par
737             {\cf19 else} {\cf19 if} (gray > 64 && gray <= 128)\par
738                 blue = ({\cf18 unsigned} char)(((128 - gray) / 64.0) * 255);\par
739             {\cf19 else}\par
740                 blue = 0;\par
741 \par
742             datadst[pos_dst] = red;\par
743             datadst[pos_dst + 1] = green;\par
744             datadst[pos_dst + 2] = blue;\par
745         \}\par
746     \}\par
747 \par
748     {\cf19 return} 1;\par
749 \}\par
}
}
{\xe \v vc_white_pixels_quantitie\:vc.h}
{\xe \v vc.h\:vc_white_pixels_quantitie}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_white_pixels_quantitie ({\b IVC} *  {\i srcdst})}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 779 \{\par
780     {\cf18 unsigned} {\cf18 char} *data = ({\cf18 unsigned} {\cf18 char} *)srcdst->data;\par
781     {\cf18 int} width = srcdst->width;\par
782     {\cf18 int} height = srcdst->height;\par
783     {\cf18 int} bytesperline = srcdst->width * srcdst->channels;\par
784     {\cf18 int} channels = srcdst->channels;\par
785     {\cf18 int} x, y, w;\par
786     {\cf18 long} {\cf18 int} pos;\par
787     w = 0;\par
788 \par
789     if ((srcdst->width <= 0) || (srcdst->height <= 0) || (srcdst->data == NULL))\par
790         {\cf19 return} 0;\par
791 \par
792     {\cf19 for} (y = 0; y < height; y++)\par
793     \{\par
794         {\cf19 for} (x = 0; x < width; x++)\par
795         \{\par
796             pos = y * bytesperline + x * channels;\par
797 \par
798             {\cf19 if} (data[pos] == 255)\par
799             \{\par
800                 w++;\par
801             \}\par
802         \}\par
803     \}\par
804     {\cf19 return} w;\par
805 \}\par
}
}
{\xe \v vc_write_image\:vc.h}
{\xe \v vc.h\:vc_write_image}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int vc_write_image (char *  {\i filename}, {\b IVC} *  {\i image})}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 321 \{\par
322     FILE *file = NULL;\par
323     {\cf18 unsigned} {\cf18 char} *tmp;\par
324     {\cf18 long} {\cf18 int} totalbytes, sizeofbinarydata;\par
325 \par
326     {\cf19 if} (image == NULL)\par
327         {\cf19 return} 0;\par
328 \par
329     {\cf19 if} ((file = fopen(filename, {\cf22 "wb"})) != NULL)\par
330     \{\par
331         {\cf19 if} (image->levels == 1)\par
332         \{\par
333             sizeofbinarydata = (image->width / 8 + ((image->width % 8) ? 1 : 0)) * image->height + 1;\par
334             tmp = ({\cf18 unsigned} {\cf18 char} *)malloc(sizeofbinarydata);\par
335             {\cf19 if} (tmp == NULL)\par
336                 {\cf19 return} 0;\par
337 \par
338             fprintf(file, {\cf22 "%s %d %d\\n"}, {\cf22 "P4"}, image->width, image->height);\par
339 \par
340             totalbytes = unsigned_char_to_bit(image->data, tmp, image->width, image->height);\par
341             printf({\cf22 "Total = %ld\\n"}, totalbytes);\par
342             {\cf19 if} (fwrite(tmp, {\cf17 sizeof}({\cf18 unsigned} {\cf18 char}), totalbytes, file) != totalbytes)\par
343             \{\par
344 {\cf21 #ifdef VC_DEBUG}\par
345                 fprintf(stderr, {\cf22 "ERROR -> vc_read_image():\\n\\tError writing PBM, PGM or PPM file.\\n"});\par
346 {\cf21 #endif}\par
347 \par
348                 fclose(file);\par
349                 free(tmp);\par
350                 {\cf19 return} 0;\par
351             \}\par
352 \par
353             free(tmp);\par
354         \}\par
355         {\cf19 else}\par
356         \{\par
357             fprintf(file, {\cf22 "%s %d %d 255\\n"}, (image->channels == 1) ? {\cf22 "P5"} : {\cf22 "P6"}, image->width, image->height);\par
358 \par
359             {\cf19 if} (fwrite(image->data, image->bytesperline, image->height, file) != image->height)\par
360             \{\par
361 {\cf21 #ifdef VC_DEBUG}\par
362                 fprintf(stderr, {\cf22 "ERROR -> vc_read_image():\\n\\tError writing PBM, PGM or PPM file.\\n"});\par
363 {\cf21 #endif}\par
364 \par
365                 fclose(file);\par
366                 {\cf19 return} 0;\par
367             \}\par
368         \}\par
369 \par
370         fclose(file);\par
371 \par
372         {\cf19 return} 1;\par
373     \}\par
374 \par
375     {\cf19 return} 0;\par
376 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vc.h\par \pard\plain 
{\tc\tcl2 \v C:/Program Files (x86)/VisaoComputador_TP/CodigoFonte/vc.h}
{\xe \v C:/Program Files (x86)/VisaoComputador_TP/CodigoFonte/vc.h}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}\par
2 {\cf20 //           INSTITUTO POLIT\'EF\'BF\'BDCNICO DO C\'EF\'BF\'BDVADO E DO AVE}\par
3 {\cf20 //                          2022/2023}\par
4 {\cf20 //             ENGENHARIA DE SISTEMAS INFORM\'EF\'BF\'BDTICOS}\par
5 {\cf20 //                    VIS\'EF\'BF\'BDO POR COMPUTADOR}\par
6 {\cf20 //}\par
7 {\cf20 //             [  DUARTE DUQUE - dduque@ipca.pt  ]}\par
8 {\cf20 //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}\par
9 \par
10 {\cf21 #define VC_DEBUG}\par
11 \par
12 {\cf21 #define MY_MAX(a, b) (a > b ? a : b)}\par
13 {\cf21 #define MY_MIN(a, b) (a < b ? a : b)}\par
14 \par
15 {\cf20 //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}\par
16 {\cf20 //                   ESTRUTURA DE UMA IMAGEM}\par
17 {\cf20 //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}\par
18 \par
19 {\cf17 typedef} {\cf17 struct}\par
20 \{\par
21     {\cf18 unsigned} {\cf18 char} *data;\par
22     {\cf18 int} width, height;\par
23     {\cf18 int} channels;     {\cf20 // Bin\'EF\'BF\'BDrio/Cinzentos=1; RGB=3}\par
24     {\cf18 int} levels;       {\cf20 // Bin\'EF\'BF\'BDrio=1; Cinzentos [1,255]; RGB [1,255]}\par
25     {\cf18 int} bytesperline; {\cf20 // width * channels}\par
26 \} IVC;\par
27 {\cf17 typedef} {\cf17 struct}\par
28 \{\par
29     {\cf18 int} x, y, width, height; {\cf20 // Caixa Delimitadora (Bounding Box)}\par
30     {\cf18 int} area;                {\cf20 // \'EF\'BF\'BDrea}\par
31     {\cf18 int} xc, yc;              {\cf20 // Centro-de-massa}\par
32     {\cf18 int} perimeter;           {\cf20 // Per\'EF\'BF\'BDmetro}\par
33     {\cf18 int} label;               {\cf20 // Etiqueta}\par
34 \} OVC;\par
35 \par
36 {\cf20 //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}\par
37 {\cf20 //                    PROT\'EF\'BF\'BDTIPOS DE FUN\'EF\'BF\'BD\'EF\'BF\'BDES}\par
38 {\cf20 //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}\par
39 \par
40 {\cf20 // FUN\'EF\'BF\'BD\'EF\'BF\'BDES: ALOCAR E LIBERTAR UMA IMAGEM}\par
41 IVC *vc_image_new({\cf18 int} width, {\cf18 int} height, {\cf18 int} channels, {\cf18 int} levels);\par
42 IVC *vc_image_free(IVC *image);\par
43 \par
44 {\cf20 // FUN\'EF\'BF\'BD\'EF\'BF\'BDES: LEITURA E ESCRITA DE IMAGENS (PBM, PGM E PPM)}\par
45 IVC *vc_read_image({\cf18 char} *filename);\par
46 {\cf18 int} vc_write_image({\cf18 char} *filename, IVC *image);\par
47 \par
48 {\cf18 int} vc_gray_negative(IVC *srcdst);\par
49 {\cf18 int} vc_rgb_negative(IVC *srcdst);\par
50 \par
51 {\cf18 int} vc_rgb_get_red_gray(IVC *srcdst);\par
52 {\cf18 int} vc_rgb_get_green_gray(IVC *srcdst);\par
53 {\cf18 int} vc_rgb_get_blue_gray(IVC *srcdst);\par
54 \par
55 {\cf18 int} vc_rgb_to_gray(IVC *src, IVC *dst);\par
56 \par
57 {\cf18 int} vc_rgb_to_hsv(IVC *srcdst);\par
58 {\cf18 int} vc_hsv_segmentation(IVC *src, IVC *dst, {\cf18 int} hmin, {\cf18 int} hmax, {\cf18 int} smin, {\cf18 int} smax, {\cf18 int} vmin, {\cf18 int} vmax);\par
59 \par
60 {\cf18 int} vc_scale_gray_to_rgb(IVC *src, IVC *dst);\par
61 {\cf18 void} combine_segmentations(IVC *dst, IVC *src1, IVC *src2);\par
62 \par
63 {\cf18 int} vc_white_pixels_quantitie(IVC *srcdst);\par
64 \par
65 {\cf18 int} vc_gray_to_binary(IVC *srcdst, {\cf18 int} threshold);\par
66 {\cf18 int} vc_gray_to_binary_global_mean(IVC *srcdst);\par
67 \par
68 {\cf18 int} vc_gray_to_binary_midpoint(IVC *src, IVC *dst, {\cf18 int} kernel);\par
69 {\cf18 int} vc_gray_to_binary_bernsen(IVC *src, IVC *dst, {\cf18 int} kernel, {\cf18 int} cmin);\par
70 {\cf18 int} vc_gray_to_binary_niblack(IVC *src, IVC *dst, {\cf18 int} kernel, {\cf18 float} k);\par
71 \par
72 {\cf18 int} vc_binary_dilate(IVC *src, IVC *dst, {\cf18 int} kernel);\par
73 {\cf18 int} vc_binary_erode(IVC *src, IVC *dst, {\cf18 int} kernel);\par
74 {\cf18 int} vc_binary_open(IVC *src, IVC *dst, {\cf18 int} kernel);\par
75 {\cf18 int} vc_binary_close(IVC *src, IVC *dst, {\cf18 int} kernel);\par
76 \par
77 {\cf18 int} vc_gray_dilate(IVC *src, IVC *dst, {\cf18 int} kernel);\par
78 {\cf18 int} vc_gray_erode(IVC *src, IVC *dst, {\cf18 int} kernel);\par
79 {\cf18 int} vc_gray_open(IVC *src, IVC *dst, {\cf18 int} kernel);\par
80 {\cf18 int} vc_gray_close(IVC *src, IVC *dst, {\cf18 int} kernel);\par
81 \par
82 {\cf18 void} combine_segmentations2(IVC *dst, IVC *src1, IVC *src2);\par
83 {\cf18 void} brancoparaoriginal(IVC *dst, IVC *src1, IVC *src2);\par
84 \par
85 OVC *vc_binary_blob_labelling(IVC *src, IVC *dst, {\cf18 int} *nlabels);\par
86 {\cf18 int} vc_binary_blob_info(IVC *src, OVC *blobs, {\cf18 int} nblobs);\par
87 \par
88 {\cf18 int} vc_coloring(IVC *src, IVC *dst, {\cf18 int} nlabels);\par
89 \par
90 {\cf18 int} vc_draw_boundingbox(IVC *srcdst, OVC *blobs, {\cf18 int} nblobs);\par
91 {\cf18 int} vc_draw_centerofgravity(IVC *srcdst, OVC *blobs, {\cf18 int} nblobs, {\cf18 int} s);\par
92 \par
93 {\cf18 int} vc_gray_histogram_show(IVC *src, IVC *dst);\par
94 {\cf18 int} vc_gray_histogram_equalization(IVC *src, IVC *dst);\par
95 \par
96 {\cf18 int} vc_gray_edge_prewitt(IVC *src, IVC *dst, {\cf18 float} th);\par
97 \par
98 {\cf18 int} vc_bgr_to_rgb(IVC *srcdst);\par
99 \par
100 {\cf20 /*}\par
101 {\cf20 }\par
102 {\cf20             Para Trabalho Final}\par
103 {\cf20 }\par
104 {\cf20 */}\par
105 \par
106 {\cf18 int} vc_bgr_to_hsv(IVC *srcdst);\par
107 {\cf18 void} brancoparaoriginal_trabalho(IVC *dst, IVC *src1, IVC *src2);\par
108 {\cf18 int} vc_hsv_segmentation_vermelho(IVC *src, IVC *dst);\par
109 {\cf18 int} vc_hsv_segmentation_castanho(IVC *src, IVC *dst);\par
110 {\cf18 int} vc_hsv_segmentation_final(IVC *src, IVC *dst);\par
111 {\cf18 int} vc_hsv_segmentation_resistencias(IVC *src, IVC *dst);\par
112 {\cf18 void} lookForWhite(IVC *src, {\cf18 int} yc, {\cf18 int} *widths);\par
113 {\cf18 int} comparePixelsAtPosition(IVC *src1, IVC *src2, {\cf18 int} yc, {\cf18 int} width);\par
114 {\cf18 int} vc_bgr_to_hsv2(IVC *src, IVC *dst);\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
